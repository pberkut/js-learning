{"mappings":"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","sources":[".yarn/cache/bootstrap.native-npm-4.2.0-6119eeefb7-ab0fdf7f0a.zip/node_modules/bootstrap.native/dist/bootstrap-native.esm.js","src/js/module-9/04-subcription.js"],"sourcesContent":["/*!\n  * Native JavaScript for Bootstrap v4.2.0 (https://thednp.github.io/bootstrap.native/)\n  * Copyright 2015-2022  dnp_theme\n  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)\n  */\n/** @type {Record<string, any>} */\nconst EventRegistry = {};\n\n/**\n * The global event listener.\n *\n * @type {EventListener}\n * @this {EventTarget}\n */\nfunction globalListener(e) {\n  const that = this;\n  const { type } = e;\n\n  [...EventRegistry[type]].forEach((elementsMap) => {\n    const [element, listenersMap] = elementsMap;\n    /* istanbul ignore else */\n    if (element === that) {\n      [...listenersMap].forEach((listenerMap) => {\n        const [listener, options] = listenerMap;\n        listener.apply(element, [e]);\n\n        if (options && options.once) {\n          removeListener(element, type, listener, options);\n        }\n      });\n    }\n  });\n}\n\n/**\n * Register a new listener with its options and attach the `globalListener`\n * to the target if this is the first listener.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst addListener = (element, eventType, listener, options) => {\n  // get element listeners first\n  if (!EventRegistry[eventType]) {\n    EventRegistry[eventType] = new Map();\n  }\n  const oneEventMap = EventRegistry[eventType];\n\n  if (!oneEventMap.has(element)) {\n    oneEventMap.set(element, new Map());\n  }\n  const oneElementMap = oneEventMap.get(element);\n\n  // get listeners size\n  const { size } = oneElementMap;\n\n  // register listener with its options\n  oneElementMap.set(listener, options);\n\n  // add listener last\n  if (!size) {\n    element.addEventListener(eventType, globalListener, options);\n  }\n};\n\n/**\n * Remove a listener from registry and detach the `globalListener`\n * if no listeners are found in the registry.\n *\n * @type {Listener.ListenerAction<EventTarget>}\n */\nconst removeListener = (element, eventType, listener, options) => {\n  // get listener first\n  const oneEventMap = EventRegistry[eventType];\n  const oneElementMap = oneEventMap && oneEventMap.get(element);\n  const savedOptions = oneElementMap && oneElementMap.get(listener);\n\n  // also recover initial options\n  const { options: eventOptions } = savedOptions !== undefined\n    ? savedOptions\n    : { options };\n\n  // unsubscribe second, remove from registry\n  if (oneElementMap && oneElementMap.has(listener)) oneElementMap.delete(listener);\n  if (oneEventMap && (!oneElementMap || !oneElementMap.size)) oneEventMap.delete(element);\n  if (!oneEventMap || !oneEventMap.size) delete EventRegistry[eventType];\n\n  // remove listener last\n  /* istanbul ignore else */\n  if (!oneElementMap || !oneElementMap.size) {\n    element.removeEventListener(eventType, globalListener, eventOptions);\n  }\n};\n\n/**\n * Advanced event listener based on subscribe / publish pattern.\n * @see https://www.patterns.dev/posts/classic-design-patterns/#observerpatternjavascript\n * @see https://gist.github.com/shystruk/d16c0ee7ac7d194da9644e5d740c8338#file-subpub-js\n * @see https://hackernoon.com/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8\n */\nconst Listener = {\n  on: addListener,\n  off: removeListener,\n  globalListener,\n  registry: EventRegistry,\n};\n\n/**\n * A global namespace for `click` event.\n * @type {string}\n */\nconst mouseclickEvent = 'click';\n\n/**\n * A global namespace for 'transitionend' string.\n * @type {string}\n */\nconst transitionEndEvent = 'transitionend';\n\n/**\n * A global namespace for 'transitionDelay' string.\n * @type {string}\n */\nconst transitionDelay = 'transitionDelay';\n\n/**\n * A global namespace for `transitionProperty` string for modern browsers.\n *\n * @type {string}\n */\nconst transitionProperty = 'transitionProperty';\n\n/**\n * Shortcut for `window.getComputedStyle(element).propertyName`\n * static method.\n *\n * * If `element` parameter is not an `HTMLElement`, `getComputedStyle`\n * throws a `ReferenceError`.\n *\n * @param {HTMLElement} element target\n * @param {string} property the css property\n * @return {string} the css property value\n */\nfunction getElementStyle(element, property) {\n  const computedStyle = getComputedStyle(element);\n\n  // must use camelcase strings,\n  // or non-camelcase strings with `getPropertyValue`\n  return property.includes('--')\n    ? computedStyle.getPropertyValue(property)\n    : computedStyle[property];\n}\n\n/**\n * Utility to get the computed `transitionDelay`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDelay(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const delayValue = getElementStyle(element, transitionDelay);\n  const delayScale = delayValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(delayValue) * delayScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * A global namespace for 'transitionDuration' string.\n * @type {string}\n */\nconst transitionDuration = 'transitionDuration';\n\n/**\n * Utility to get the computed `transitionDuration`\n * from Element in miliseconds.\n *\n * @param {HTMLElement} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDuration(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const durationValue = getElementStyle(element, transitionDuration);\n  const durationScale = durationValue.includes('ms') ? /* istanbul ignore next */1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(durationValue) * durationScale : 0;\n\n  return !Number.isNaN(duration) ? duration : /* istanbul ignore next */0;\n}\n\n/**\n * Shortcut for the `Element.dispatchEvent(Event)` method.\n *\n * @param {HTMLElement} element is the target\n * @param {Event} event is the `Event` object\n */\nconst dispatchEvent = (element, event) => element.dispatchEvent(event);\n\n/**\n * Utility to make sure callbacks are consistently\n * called when transition ends.\n *\n * @param {HTMLElement} element target\n * @param {EventListener} handler `transitionend` callback\n */\nfunction emulateTransitionEnd(element, handler) {\n  let called = 0;\n  const endEvent = new Event(transitionEndEvent);\n  const duration = getElementTransitionDuration(element);\n  const delay = getElementTransitionDelay(element);\n\n  if (duration) {\n    /**\n     * Wrap the handler in on -> off callback\n     * @type {EventListener} e Event object\n     */\n    const transitionEndWrapper = (e) => {\n      /* istanbul ignore else */\n      if (e.target === element) {\n        handler.apply(element, [e]);\n        element.removeEventListener(transitionEndEvent, transitionEndWrapper);\n        called = 1;\n      }\n    };\n    element.addEventListener(transitionEndEvent, transitionEndWrapper);\n    setTimeout(() => {\n      /* istanbul ignore next */\n      if (!called) dispatchEvent(element, endEvent);\n    }, duration + delay + 17);\n  } else {\n    handler.apply(element, [endEvent]);\n  }\n}\n\n/**\n * Checks if an object is a `Node`.\n *\n * @param {any} node the target object\n * @returns {boolean} the query result\n */\nconst isNode = (element) => (element && [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  .some((x) => +element.nodeType === x)) || false;\n\n/**\n * Check if a target object is `Window`.\n * => equivalent to `object instanceof Window`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isWindow = (object) => (object && object.constructor.name === 'Window') || false;\n\n/**\n * Checks if an object is a `Document`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isDocument = (object) => (object && object.nodeType === 9) || false;\n\n/**\n * Returns the `document` or the `#document` element.\n * @see https://github.com/floating-ui/floating-ui\n * @param {(Node | Window)=} node\n * @returns {Document}\n */\nfunction getDocument(node) {\n  // node instanceof Document\n  if (isDocument(node)) return node;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument;\n  // node instanceof Window\n  if (isWindow(node)) return node.document;\n  // node is undefined | NULL\n  return window.document;\n}\n\n/**\n * Utility to check if target is typeof `HTMLElement`, `Element`, `Node`\n * or find one that matches a selector.\n *\n * @param {Node | string} selector the input selector or target element\n * @param {ParentNode=} parent optional node to look into\n * @return {HTMLElement?} the `HTMLElement` or `querySelector` result\n */\nfunction querySelector(selector, parent) {\n  if (isNode(selector)) {\n    return selector;\n  }\n  const lookUp = isNode(parent) ? parent : getDocument();\n\n  return lookUp.querySelector(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.closest` method which also works\n * with children of `ShadowRoot`. The order of the parameters\n * is intentional since they're both required.\n *\n * @see https://stackoverflow.com/q/54520554/803358\n *\n * @param {HTMLElement} element Element to look into\n * @param {string} selector the selector name\n * @return {HTMLElement?} the query result\n */\nfunction closest(element, selector) {\n  return element ? (element.closest(selector)\n    // break out of `ShadowRoot`\n    || closest(element.getRootNode().host, selector)) : null;\n}\n\n/**\n * Shortcut for `Object.assign()` static method.\n * @param  {Record<string, any>} obj a target object\n * @param  {Record<string, any>} source a source object\n */\nconst ObjectAssign = (obj, source) => Object.assign(obj, source);\n\n/**\n * Check class in `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to check\n * @returns {boolean}\n */\nfunction hasClass(element, classNAME) {\n  return element.classList.contains(classNAME);\n}\n\n/**\n * Remove class from `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to remove\n * @returns {void}\n */\nfunction removeClass(element, classNAME) {\n  element.classList.remove(classNAME);\n}\n\n/**\n * Checks if an element is an `HTMLElement`.\n * @see https://dom.spec.whatwg.org/#node\n *\n * @param {any} element the target object\n * @returns {boolean} the query result\n */\nconst isHTMLElement = (element) => (element && element.nodeType === 1) || false;\n\n/** @type {Map<string, Map<HTMLElement, Record<string, any>>>} */\nconst componentData = new Map();\n/**\n * An interface for web components background data.\n * @see https://github.com/thednp/bootstrap.native/blob/master/src/components/base-component.js\n */\nconst Data = {\n  /**\n   * Sets web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @param {Record<string, any>} instance the component instance\n   */\n  set: (element, component, instance) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (!componentData.has(component)) {\n      componentData.set(component, new Map());\n    }\n\n    const instanceMap = componentData.get(component);\n    // not undefined, but defined right above\n    instanceMap.set(element, instance);\n  },\n\n  /**\n   * Returns all instances for specified component.\n   * @param {string} component the component's name or a unique key\n   * @returns {Map<HTMLElement, Record<string, any>>?} all the component instances\n   */\n  getAllFor: (component) => {\n    const instanceMap = componentData.get(component);\n\n    return instanceMap || null;\n  },\n\n  /**\n   * Returns the instance associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   * @returns {Record<string, any>?} the instance\n   */\n  get: (element, component) => {\n    if (!isHTMLElement(element) || !component) return null;\n    const allForC = Data.getAllFor(component);\n    const instance = element && allForC && allForC.get(element);\n\n    return instance || null;\n  },\n\n  /**\n   * Removes web components data.\n   * @param {HTMLElement} element target element\n   * @param {string} component the component's name or a unique key\n   */\n  remove: (element, component) => {\n    const instanceMap = componentData.get(component);\n    if (!instanceMap || !isHTMLElement(element)) return;\n\n    instanceMap.delete(element);\n\n    /* istanbul ignore else */\n    if (instanceMap.size === 0) {\n      componentData.delete(component);\n    }\n  },\n};\n\n/**\n * An alias for `Data.get()`.\n * @type {SHORTY.getInstance<any>}\n */\nconst getInstance = (target, component) => Data.get(target, component);\n\n/**\n * Checks if an object is an `Object`.\n *\n * @param {any} obj the target object\n * @returns {boolean} the query result\n */\nconst isObject = (obj) => (typeof obj === 'object') || false;\n\n/**\n * Returns a namespaced `CustomEvent` specific to each component.\n * @param {string} EventType Event.type\n * @param {Record<string, any>=} config Event.options | Event.properties\n * @returns {SHORTY.OriginalEvent} a new namespaced event\n */\nfunction OriginalEvent(EventType, config) {\n  const OriginalCustomEvent = new CustomEvent(EventType, {\n    cancelable: true, bubbles: true,\n  });\n\n  /* istanbul ignore else */\n  if (isObject(config)) {\n    ObjectAssign(OriginalCustomEvent, config);\n  }\n  return OriginalCustomEvent;\n}\n\n/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = 'fade';\n\n/**\n * Global namespace for most components `show` class.\n */\nconst showClass = 'show';\n\n/**\n * Global namespace for most components `dismiss` option.\n */\nconst dataBsDismiss = 'data-bs-dismiss';\n\n/** @type {string} */\nconst alertString = 'alert';\n\n/** @type {string} */\nconst alertComponent = 'Alert';\n\n/**\n * Shortcut for `HTMLElement.getAttribute()` method.\n * @param {HTMLElement} element target element\n * @param {string} attribute attribute name\n * @returns {string?} attribute value\n */\nconst getAttribute = (element, attribute) => element.getAttribute(attribute);\n\n/**\n * The raw value or a given component option.\n *\n * @typedef {string | HTMLElement | Function | number | boolean | null} niceValue\n */\n\n/**\n * Utility to normalize component options\n *\n * @param {any} value the input value\n * @return {niceValue} the normalized value\n */\nfunction normalizeValue(value) {\n  if (['true', true].includes(value)) { // boolean\n  // if ('true' === value) { // boolean\n    return true;\n  }\n\n  if (['false', false].includes(value)) { // boolean\n  // if ('false' === value) { // boolean\n    return false;\n  }\n\n  if (value === '' || value === 'null') { // null\n    return null;\n  }\n\n  if (value !== '' && !Number.isNaN(+value)) { // number\n    return +value;\n  }\n\n  // string / function / HTMLElement / object\n  return value;\n}\n\n/**\n * Shortcut for `Object.keys()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {string[]}\n */\nconst ObjectKeys = (obj) => Object.keys(obj);\n\n/**\n * Shortcut for `String.toLowerCase()`.\n *\n * @param {string} source input string\n * @returns {string} lowercase output string\n */\nconst toLowerCase = (source) => source.toLowerCase();\n\n/**\n * Utility to normalize component options.\n *\n * @param {HTMLElement} element target\n * @param {Record<string, any>} defaultOps component default options\n * @param {Record<string, any>} inputOps component instance options\n * @param {string=} ns component namespace\n * @return {Record<string, any>} normalized component options object\n */\nfunction normalizeOptions(element, defaultOps, inputOps, ns) {\n  const data = { ...element.dataset };\n  /** @type {Record<string, any>} */\n  const normalOps = {};\n  /** @type {Record<string, any>} */\n  const dataOps = {};\n  const title = 'title';\n\n  ObjectKeys(data).forEach((k) => {\n    const key = ns && k.includes(ns)\n      ? k.replace(ns, '').replace(/[A-Z]/, (match) => toLowerCase(match))\n      : k;\n\n    dataOps[key] = normalizeValue(data[k]);\n  });\n\n  ObjectKeys(inputOps).forEach((k) => {\n    inputOps[k] = normalizeValue(inputOps[k]);\n  });\n\n  ObjectKeys(defaultOps).forEach((k) => {\n    /* istanbul ignore else */\n    if (k in inputOps) {\n      normalOps[k] = inputOps[k];\n    } else if (k in dataOps) {\n      normalOps[k] = dataOps[k];\n    } else {\n      normalOps[k] = k === title\n        ? getAttribute(element, title)\n        : defaultOps[k];\n    }\n  });\n\n  return normalOps;\n}\n\nvar version = \"4.2.0\";\n\nconst Version = version;\n\n/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\n\n/** Returns a new `BaseComponent` instance. */\nclass BaseComponent {\n  /**\n   * @param {HTMLElement | string} target `Element` or selector string\n   * @param {BSN.ComponentOptions=} config component instance options\n   */\n  constructor(target, config) {\n    const self = this;\n    const element = querySelector(target);\n\n    if (!element) {\n      throw Error(`${self.name} Error: \"${target}\" is not a valid selector.`);\n    }\n\n    /** @static @type {BSN.ComponentOptions} */\n    self.options = {};\n\n    const prevInstance = Data.get(element, self.name);\n    if (prevInstance) prevInstance.dispose();\n\n    /** @type {HTMLElement} */\n    self.element = element;\n\n    /* istanbul ignore else */\n    if (self.defaults && ObjectKeys(self.defaults).length) {\n      self.options = normalizeOptions(element, self.defaults, (config || {}), 'bs');\n    }\n\n    Data.set(element, self.name, self);\n  }\n\n  /* eslint-disable */\n  /* istanbul ignore next */\n  /** @static */\n  get version() { return Version; }\n\n  /* eslint-enable */\n  /* istanbul ignore next */\n  /** @static */\n  get name() { return this.constructor.name; }\n\n  /* istanbul ignore next */\n  /** @static */\n  get defaults() { return this.constructor.defaults; }\n\n  /**\n   * Removes component from target element;\n   */\n  dispose() {\n    const self = this;\n    Data.remove(self.element, self.name);\n    ObjectKeys(self).forEach((prop) => { self[prop] = null; });\n  }\n}\n\n/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Alert>}\n */\nconst getAlertInstance = (element) => getInstance(element, alertComponent);\n\n/**\n* An `Alert` initialization callback.\n* @type {BSN.InitCallback<Alert>}\n*/\nconst alertInitCallback = (element) => new Alert(element);\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = OriginalEvent(`close.bs.${alertString}`);\nconst closedAlertEvent = OriginalEvent(`closed.bs.${alertString}`);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n * @param {Alert} self target Alert instance\n */\nfunction alertTransitionEnd(self) {\n  const { element } = self;\n  toggleAlertHandler(self);\n\n  dispatchEvent(element, closedAlertEvent);\n\n  self.dispose();\n  element.remove();\n}\n\n// ALERT PRIVATE METHOD\n// ====================\n/**\n * Toggle on / off the `click` event listener.\n * @param {Alert} self the target alert instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleAlertHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { dismiss } = self;\n  /* istanbul ignore else */\n  if (dismiss) action(dismiss, mouseclickEvent, self.close);\n}\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nclass Alert extends BaseComponent {\n  /** @param {HTMLElement | string} target element or selector */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // the dismiss button\n    /** @static @type {HTMLElement?} */\n    self.dismiss = querySelector(alertDismissSelector, element);\n\n    // add event listener\n    toggleAlertHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return alertComponent; }\n  /* eslint-enable */\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   *\n   * @param {Event=} e most likely the `click` event\n   * @this {Alert} the `Alert` instance or `EventTarget`\n   */\n  close(e) {\n    const self = e ? getAlertInstance(closest(this, alertSelector)) : this;\n    const { element } = self;\n\n    /* istanbul ignore else */\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n      if (closeAlertEvent.defaultPrevented) return;\n\n      removeClass(element, showClass);\n\n      if (hasClass(element, fadeClass)) {\n        emulateTransitionEnd(element, () => alertTransitionEnd(self));\n      } else alertTransitionEnd(self);\n    }\n  }\n\n  /** Remove the component from target element. */\n  dispose() {\n    toggleAlertHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Alert, {\n  selector: alertSelector,\n  init: alertInitCallback,\n  getInstance: getAlertInstance,\n});\n\n/**\n * A global namespace for aria-pressed.\n * @type {string}\n */\nconst ariaPressed = 'aria-pressed';\n\n/**\n * Shortcut for `HTMLElement.setAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @param  {string} value attribute value\n * @returns {void}\n */\nconst setAttribute = (element, attribute, value) => element.setAttribute(attribute, value);\n\n/**\n * Add class to `HTMLElement.classList`.\n *\n * @param {HTMLElement} element target\n * @param {string} classNAME to add\n * @returns {void}\n */\nfunction addClass(element, classNAME) {\n  element.classList.add(classNAME);\n}\n\n/**\n * Global namespace for most components active class.\n */\nconst activeClass = 'active';\n\n/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = 'data-bs-toggle';\n\n/** @type {string} */\nconst buttonString = 'button';\n\n/** @type {string} */\nconst buttonComponent = 'Button';\n\n/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Button>}\n */\nconst getButtonInstance = (element) => getInstance(element, buttonComponent);\n\n/**\n * A `Button` initialization callback.\n * @type {BSN.InitCallback<Button>}\n */\nconst buttonInitCallback = (element) => new Button(element);\n\n// BUTTON PRIVATE METHOD\n// =====================\n/**\n * Toggles on/off the `click` event listener.\n * @param {Button} self the `Button` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleButtonHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, self.toggle);\n}\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nclass Button extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually a `.btn` element\n   */\n  constructor(target) {\n    super(target);\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // set initial state\n    /** @type {boolean} */\n    self.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, `${!!self.isActive}`);\n\n    // add event listener\n    toggleButtonHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return buttonComponent; }\n  /* eslint-enable */\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   * @param {MouseEvent} e usually `click` Event object\n   */\n  toggle(e) {\n    if (e) e.preventDefault();\n    const self = e ? getButtonInstance(this) : this;\n    if (!self.element) return;\n    const { element, isActive } = self;\n\n    if (hasClass(element, 'disabled')) return;\n\n    const action = isActive ? removeClass : addClass;\n    action(element, activeClass);\n    setAttribute(element, ariaPressed, isActive ? 'false' : 'true');\n    self.isActive = hasClass(element, activeClass);\n  }\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    toggleButtonHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Button, {\n  selector: buttonSelector,\n  init: buttonInitCallback,\n  getInstance: getButtonInstance,\n});\n\n/**\n * A global namespace for `mouseenter` event.\n * @type {string}\n */\nconst mouseenterEvent = 'mouseenter';\n\n/**\n * A global namespace for `mouseleave` event.\n * @type {string}\n */\nconst mouseleaveEvent = 'mouseleave';\n\n/**\n * A global namespace for `keydown` event.\n * @type {string}\n */\nconst keydownEvent = 'keydown';\n\n/**\n * A global namespace for `ArrowLeft` key.\n * @type {string} e.which = 37 equivalent\n */\nconst keyArrowLeft = 'ArrowLeft';\n\n/**\n * A global namespace for `ArrowRight` key.\n * @type {string} e.which = 39 equivalent\n */\nconst keyArrowRight = 'ArrowRight';\n\n/**\n * A global namespace for `pointerdown` event.\n * @type {string}\n */\nconst pointerdownEvent = 'pointerdown';\n\n/**\n * A global namespace for `pointermove` event.\n * @type {string}\n */\nconst pointermoveEvent = 'pointermove';\n\n/**\n * A global namespace for `pointerup` event.\n * @type {string}\n */\nconst pointerupEvent = 'pointerup';\n\n/**\n * Returns the bounding client rect of a target `HTMLElement`.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element event.target\n * @param {boolean=} includeScale when *true*, the target scale is also computed\n * @returns {SHORTY.BoundingClientRect} the bounding client rect object\n */\nfunction getBoundingClientRect(element, includeScale) {\n  const {\n    width, height, top, right, bottom, left,\n  } = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    const { offsetWidth, offsetHeight } = element;\n    scaleX = offsetWidth > 0 ? Math.round(width) / offsetWidth\n      : /* istanbul ignore next */1;\n    scaleY = offsetHeight > 0 ? Math.round(height) / offsetHeight\n      : /* istanbul ignore next */1;\n  }\n\n  return {\n    width: width / scaleX,\n    height: height / scaleY,\n    top: top / scaleY,\n    right: right / scaleX,\n    bottom: bottom / scaleY,\n    left: left / scaleX,\n    x: left / scaleX,\n    y: top / scaleY,\n  };\n}\n\n/**\n * Returns the `document.documentElement` or the `<html>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLHtmlElement}\n */\nfunction getDocumentElement(node) {\n  return getDocument(node).documentElement;\n}\n\n/**\n * Utility to determine if an `HTMLElement`\n * is partially visible in viewport.\n *\n * @param {HTMLElement} element target\n * @return {boolean} the query result\n */\nconst isElementInScrollRange = (element) => {\n  if (!element || !isNode(element)) return false;\n\n  const { top, bottom } = getBoundingClientRect(element);\n  const { clientHeight } = getDocumentElement(element);\n  return top <= clientHeight && bottom >= 0;\n};\n\n/**\n * Checks if a page is Right To Left.\n * @param {HTMLElement=} node the target\n * @returns {boolean} the query result\n */\nconst isRTL = (node) => getDocumentElement(node).dir === 'rtl';\n\n/**\n * A shortcut for `(document|Element).querySelectorAll`.\n *\n * @param {string} selector the input selector\n * @param {ParentNode=} parent optional node to look into\n * @return {NodeListOf<HTMLElement>} the query result\n */\nfunction querySelectorAll(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.querySelectorAll(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.getElementsByClassName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByClassName`.\n *\n * @param {string} selector the class name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByClassName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByClassName(selector);\n}\n\n/** @type {Map<HTMLElement, any>} */\nconst TimeCache = new Map();\n/**\n * An interface for one or more `TimerHandler`s per `Element`.\n * @see https://github.com/thednp/navbar.js/\n */\nconst Timer = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   * @param {HTMLElement} element target element\n   * @param {ReturnType<TimerHandler>} callback the callback\n   * @param {number} delay the execution delay\n   * @param {string=} key a unique key\n   */\n  set: (element, callback, delay, key) => {\n    if (!isHTMLElement(element)) return;\n\n    /* istanbul ignore else */\n    if (key && key.length) {\n      /* istanbul ignore else */\n      if (!TimeCache.has(element)) {\n        TimeCache.set(element, new Map());\n      }\n      const keyTimers = TimeCache.get(element);\n      keyTimers.set(key, setTimeout(callback, delay));\n    } else {\n      TimeCache.set(element, setTimeout(callback, delay));\n    }\n  },\n\n  /**\n   * Returns the timer associated with the target.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique\n   * @returns {number?} the timer\n   */\n  get: (element, key) => {\n    if (!isHTMLElement(element)) return null;\n    const keyTimers = TimeCache.get(element);\n\n    if (key && key.length && keyTimers && keyTimers.get) {\n      return keyTimers.get(key) || /* istanbul ignore next */null;\n    }\n    return keyTimers || null;\n  },\n\n  /**\n   * Clears the element's timer.\n   * @param {HTMLElement} element target element\n   * @param {string=} key a unique key\n   */\n  clear: (element, key) => {\n    if (!isHTMLElement(element)) return;\n\n    if (key && key.length) {\n      const keyTimers = TimeCache.get(element);\n      /* istanbul ignore else */\n      if (keyTimers && keyTimers.get) {\n        clearTimeout(keyTimers.get(key));\n        keyTimers.delete(key);\n        /* istanbul ignore else */\n        if (keyTimers.size === 0) {\n          TimeCache.delete(element);\n        }\n      }\n    } else {\n      clearTimeout(TimeCache.get(element));\n      TimeCache.delete(element);\n    }\n  },\n};\n\n/**\n * Utility to force re-paint of an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n * @return {number} the `Element.offsetHeight` value\n */\nconst reflow = (element) => element.offsetHeight;\n\n/**\n * A global namespace for most scroll event listeners.\n * @type {Partial<AddEventListenerOptions>}\n */\nconst passiveHandler = { passive: true };\n\n/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = 'data-bs-target';\n\n/** @type {string} */\nconst carouselString = 'carousel';\n\n/** @type {string} */\nconst carouselComponent = 'Carousel';\n\n/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = 'data-bs-parent';\n\n/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = 'data-bs-container';\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param {HTMLElement} element the target element\n * @returns {HTMLElement?} the query result\n */\nfunction getTargetElement(element) {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, 'href'];\n  const doc = getDocument(element);\n\n  return targetAttr.map((att) => {\n    const attValue = getAttribute(element, att);\n    if (attValue) {\n      return att === dataBsParent ? closest(element, attValue) : querySelector(attValue, doc);\n    }\n    return null;\n  }).filter((x) => x)[0];\n}\n\n/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Carousel>}\n */\nconst getCarouselInstance = (element) => getInstance(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n * @type {BSN.InitCallback<Carousel>}\n */\nconst carouselInitCallback = (element) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = OriginalEvent(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = OriginalEvent(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n * @param {Carousel} self the `Carousel` instance\n */\nfunction carouselTransitionEndHandler(self) {\n  const {\n    index, direction, element, slides, options,\n  } = self;\n\n  // discontinue disposed instances\n  /* istanbul ignore else */\n  if (self.isAnimating && getCarouselInstance(element)) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // check for element, might have been disposed\n    if (!getDocument(element).hidden && options.interval\n      && !self.isPaused) {\n      self.cycle();\n    }\n  }\n}\n\n/**\n * Handles the `mouseenter` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselPauseHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && !self.isPaused && !Timer.get(element, pausedClass)) {\n    addClass(element, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement}\n */\nfunction carouselResumeHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n  /* istanbul ignore else */\n  if (self && self.isPaused && !Timer.get(element, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselIndicatorHandler(e) {\n  e.preventDefault();\n  const indicator = this;\n  const element = closest(indicator, carouselSelector) || getTargetElement(indicator);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n\n  const newIndex = +getAttribute(indicator, dataBsSlideTo);\n\n  if (indicator && !hasClass(indicator, activeClass) // event target is not active\n    && !Number.isNaN(newIndex)) { // AND has the specific attribute\n    self.to(newIndex); // do the slide\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselControlsHandler(e) {\n  e.preventDefault();\n  const control = this;\n  const element = closest(control, carouselSelector) || getTargetElement(control);\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n  const orientation = getAttribute(control, dataBsSlide);\n\n  /* istanbul ignore else */\n  if (orientation === 'next') {\n    self.next();\n  } else if (orientation === 'prev') {\n    self.prev();\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction carouselKeyHandler({ code, target }) {\n  const doc = getDocument(target);\n  const [element] = [...querySelectorAll(carouselSelector, doc)]\n    .filter((x) => isElementInScrollRange(x));\n  const self = getCarouselInstance(element);\n\n  /* istanbul ignore next */\n  if (!self || self.isAnimating || /textarea|input/i.test(target.tagName)) return;\n  const RTL = isRTL(element);\n  const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n  const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n  /* istanbul ignore else */\n  if (code === arrowKeyPrev) self.prev();\n  else if (code === arrowKeyNext) self.next();\n}\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Handles the `pointerdown` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e the `Event` object\n */\nfunction carouselPointerDownHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getCarouselInstance(element);\n\n  // filter pointer event on controls & indicators\n  const { controls, indicators } = self;\n  if ([...controls, ...indicators].some((el) => (el === target || el.contains(target)))) {\n    return;\n  }\n\n  if (!self || self.isAnimating || self.isTouch) { return; }\n\n  startX = e.pageX;\n\n  /* istanbul ignore else */\n  if (element.contains(target)) {\n    self.isTouch = true;\n    toggleCarouselTouchHandlers(self, true);\n  }\n}\n\n/**\n * Handles the `pointermove` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n * @param {PointerEvent} e\n */\nfunction carouselPointerMoveHandler(e) {\n  // const self = getCarouselInstance(this);\n\n  // if (!self || !self.isTouch) { return; }\n\n  currentX = e.pageX;\n}\n\n/**\n * Handles the `pointerup` event for the `Carousel` element.\n *\n * @this {HTMLElement}\n\n * @param {PointerEvent} e\n */\nfunction carouselPointerUpHandler(e) {\n  const { target } = e;\n  const doc = getDocument(target);\n  const self = [...querySelectorAll(carouselSelector, doc)]\n    .map((c) => getCarouselInstance(c)).find((i) => i.isTouch);\n\n  // impossible to satisfy\n  /* istanbul ignore next */\n  if (!self) { return; }\n\n  const { element, index } = self;\n  const RTL = isRTL(target);\n\n  self.isTouch = false;\n  toggleCarouselTouchHandlers(self);\n\n  if (doc.getSelection().toString().length) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n\n  endX = e.pageX;\n\n  // the event target is outside the carousel context\n  // OR swipe distance is less than 120px\n  /* istanbul ignore else */\n  if (!element.contains(target) || Math.abs(startX - endX) < 120) {\n    // reset pointer position\n    startX = 0; currentX = 0; endX = 0;\n    return;\n  }\n  // OR determine next index to slide to\n  /* istanbul ignore else */\n  if (currentX < startX) {\n    self.to(index + (RTL ? -1 : 1));\n  } else if (currentX > startX) {\n    self.to(index + (RTL ? 1 : -1));\n  }\n  // reset pointer position\n  startX = 0; currentX = 0; endX = 0;\n}\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {number} pageIndex the index of the new active indicator\n */\nfunction activateCarouselIndicator(self, pageIndex) {\n  const { indicators } = self;\n  [...indicators].forEach((x) => removeClass(x, activeClass));\n\n  /* istanbul ignore else */\n  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);\n}\n\n/**\n * Toggles the pointer event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselTouchHandlers(self, add) {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(getDocument(element), pointermoveEvent, carouselPointerMoveHandler, passiveHandler);\n  action(getDocument(element), pointerupEvent, carouselPointerUpHandler, passiveHandler);\n}\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselHandlers(self, add) {\n  const {\n    element, options, slides, controls, indicators,\n  } = self;\n  const {\n    touch, pause, interval, keyboard,\n  } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n  }\n\n  if (touch && slides.length > 2) {\n    action(element, pointerdownEvent, carouselPointerDownHandler, passiveHandler);\n  }\n\n  /* istanbul ignore else */\n  if (controls.length) {\n    controls.forEach((arrow) => {\n      /* istanbul ignore else */\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n    });\n  }\n\n  /* istanbul ignore else */\n  if (indicators.length) {\n    indicators.forEach((indicator) => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler);\n    });\n  }\n\n  if (keyboard) action(getDocument(element), keydownEvent, carouselKeyHandler);\n}\n\n/**\n * Returns the index of the current active item.\n * @param {Carousel} self the `Carousel` instance\n * @returns {number} the query result\n */\nfunction getActiveIndex(self) {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  return [...slides].indexOf(activeItem);\n}\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nclass Carousel extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target mostly a `.carousel` element\n   * @param {BSN.Options.Carousel=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    // initialization element\n    const { element } = self;\n\n    // additional properties\n    /** @type {string} */\n    self.direction = isRTL(element) ? 'right' : 'left';\n    /** @type {number} */\n    self.index = 0;\n    /** @type {boolean} */\n    self.isTouch = false;\n\n    // carousel elements\n    // a LIVE collection is prefferable\n    self.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = self;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length < 2) { return; }\n    // external controls must be within same document context\n    const doc = getDocument(element);\n\n    self.controls = [\n      ...querySelectorAll(`[${dataBsSlide}]`, element),\n      ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    /** @type {HTMLElement?} */\n    self.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n    // a LIVE collection is prefferable\n    /** @type {HTMLElement[]} */\n    self.indicators = [\n      ...(self.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, self.indicator) : []),\n      ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`, doc),\n    ];\n\n    // set JavaScript and DATA API options\n    const { options } = self;\n\n    // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n    self.options.interval = options.interval === true\n      ? carouselDefaults.interval\n      : options.interval;\n\n    // set first slide active if none\n    /* istanbul ignore else */\n    if (getActiveIndex(self) < 0) {\n      addClass(slides[0], activeClass);\n      /* istanbul ignore else */\n      if (self.indicators.length) activateCarouselIndicator(self, 0);\n    }\n\n    // attach event handlers\n    toggleCarouselHandlers(self, true);\n\n    // start to cycle if interval is set\n    if (options.interval) self.cycle();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return carouselComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return carouselDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Check if instance is paused.\n   * @returns {boolean}\n  */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   * @returns {boolean}\n  */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const self = this;\n    const {\n      element, options, isPaused, index,\n    } = self;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(element, () => {\n      // it's very important to check self.element\n      // where instance might have been disposed\n      /* istanbul ignore else */\n      if (self.element && !self.isPaused && !self.isTouch\n        && isElementInScrollRange(element)) {\n        self.to(index + 1);\n      }\n    }, options.interval, carouselString);\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const self = this;\n    const { element, options } = self;\n    /* istanbul ignore else */\n    if (!self.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(element, () => {}, 1, pausedClass);\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index + 1); }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    const self = this;\n    /* istanbul ignore else */\n    if (!self.isAnimating) { self.to(self.index - 1); }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   * @param {number} idx the index of the item to jump to\n   */\n  to(idx) {\n    const self = this;\n    const {\n      element, slides, options,\n    } = self;\n    const activeItem = getActiveIndex(self);\n    const RTL = isRTL(element);\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    // `to()` must be SPAM protected by Timer\n    if (self.isAnimating || activeItem === next || Timer.get(element, dataBsSlide)) return;\n\n    // determine transition direction\n    /* istanbul ignore else */\n    if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {\n      self.direction = RTL ? 'right' : 'left'; // next\n    } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {\n      self.direction = RTL ? 'left' : 'right'; // prev\n    }\n    const { direction } = self;\n\n    // find the right next index\n    if (next < 0) { next = slides.length - 1; } else if (next >= slides.length) { next = 0; }\n\n    // orientation, class name, eventProperties\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    const eventProperties = {\n      relatedTarget: slides[next],\n      from: activeItem,\n      to: next,\n      direction,\n    };\n\n    // update event properties\n    ObjectAssign(carouselSlideEvent, eventProperties);\n    ObjectAssign(carouselSlidEvent, eventProperties);\n\n    // discontinue when prevented\n    dispatchEvent(element, carouselSlideEvent);\n    if (carouselSlideEvent.defaultPrevented) return;\n\n    // update index\n    self.index = next;\n    activateCarouselIndicator(self, next);\n\n    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n      Timer.set(element, () => {\n        addClass(slides[next], `${carouselItem}-${orientation}`);\n        reflow(slides[next]);\n        addClass(slides[next], `${carouselItem}-${directionClass}`);\n        addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n        emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(self));\n      }, 0, dataBsSlide);\n    } else {\n      addClass(slides[next], activeClass);\n      removeClass(slides[activeItem], activeClass);\n\n      Timer.set(element, () => {\n        Timer.clear(element, dataBsSlide);\n        // check for element, might have been disposed\n        /* istanbul ignore else */\n        if (element && options.interval && !self.isPaused) {\n          self.cycle();\n        }\n\n        dispatchEvent(element, carouselSlidEvent);\n      }, 0, dataBsSlide);\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const self = this;\n    const { slides } = self;\n    const itemClasses = ['start', 'end', 'prev', 'next'];\n\n    [...slides].forEach((slide, idx) => {\n      if (hasClass(slide, activeClass)) activateCarouselIndicator(self, idx);\n      itemClasses.forEach((c) => removeClass(slide, `${carouselItem}-${c}`));\n    });\n\n    toggleCarouselHandlers(self);\n    super.dispose();\n  }\n}\n\nObjectAssign(Carousel, {\n  selector: carouselSelector,\n  init: carouselInitCallback,\n  getInstance: getCarouselInstance,\n});\n\n/**\n * A global namespace for aria-expanded.\n * @type {string}\n */\nconst ariaExpanded = 'aria-expanded';\n\n/**\n * Shortcut for `Object.entries()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {[string, any][]}\n */\nconst ObjectEntries = (obj) => Object.entries(obj);\n\n/**\n * Shortcut for multiple uses of `HTMLElement.style.propertyName` method.\n * @param  {HTMLElement} element target element\n * @param  {Partial<CSSStyleDeclaration>} styles attribute value\n */\nconst setElementStyle = (element, styles) => {\n  ObjectEntries(styles).forEach(([key, value]) => {\n    if (key.includes('--')) {\n      element.style.setProperty(key, value);\n    } else {\n      const propObject = {}; propObject[key] = value;\n      ObjectAssign(element.style, propObject);\n    }\n  });\n};\n\n/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = 'collapsing';\n\n/** @type {string} */\nconst collapseString = 'collapse';\n\n/** @type {string} */\nconst collapseComponent = 'Collapse';\n\n/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Collapse>}\n */\nconst getCollapseInstance = (element) => getInstance(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n * @type {BSN.InitCallback<Collapse>}\n */\nconst collapseInitCallback = (element) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = OriginalEvent(`show.bs.${collapseString}`);\nconst shownCollapseEvent = OriginalEvent(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = OriginalEvent(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = OriginalEvent(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction expandCollapse(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (showCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  addClass(element, collapsingClass);\n  removeClass(element, collapseString);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'true'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n    addClass(element, showClass);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, shownCollapseEvent);\n  });\n}\n\n/**\n * Collapse the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction collapseContent(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (hideCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  setElementStyle(element, { height: `${element.scrollHeight}px` });\n\n  removeClass(element, collapseString);\n  removeClass(element, showClass);\n  addClass(element, collapsingClass);\n\n  reflow(element);\n  setElementStyle(element, { height: '0px' });\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    /* istanbul ignore else */\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'false'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n\n    setElementStyle(element, { height: '' });\n\n    dispatchEvent(element, hiddenCollapseEvent);\n  });\n}\n\n/**\n * Toggles on/off the event listener(s) of the `Collapse` instance.\n * @param {Collapse} self the `Collapse` instance\n * @param {boolean=} add when `true`, the event listener is added\n */\nfunction toggleCollapseHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, collapseClickHandler));\n  }\n}\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n * @param {MouseEvent} e the `Event` object\n */\nfunction collapseClickHandler(e) {\n  const { target } = e; // our target is `HTMLElement`\n  const trigger = target && closest(target, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  /* istanbul ignore else */\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nclass Collapse extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target and `Element` that matches the selector\n   * @param {BSN.Options.Collapse=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element, options } = self;\n    const doc = getDocument(element);\n\n    // set triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(collapseToggleSelector, doc)]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // set parent accordion\n    /** @type {HTMLElement?} */\n    self.parent = querySelector(options.parent, doc)\n      || getTargetElement(element) || null;\n\n    // add event listeners\n    toggleCollapseHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return collapseComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return collapseDefaults; }\n  /* eslint-enable */\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    const self = this;\n    if (!hasClass(self.element, showClass)) self.show();\n    else self.hide();\n  }\n\n  /** Hides the collapse. */\n  hide() {\n    const self = this;\n    const { triggers, element } = self;\n    if (Timer.get(element)) return;\n\n    collapseContent(self);\n    /* istanbul ignore else */\n    if (triggers.length) {\n      triggers.forEach((btn) => addClass(btn, `${collapseString}d`));\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const self = this;\n    const {\n      element, parent, triggers,\n    } = self;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [...querySelectorAll(`.${collapseString}.${showClass}`, parent)]\n        .find((i) => getCollapseInstance(i));\n      activeCollapseInstance = activeCollapse && getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || !Timer.get(parent)) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach((btn) => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(self);\n      /* istanbul ignore else */\n      if (triggers.length) {\n        triggers.forEach((btn) => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    const self = this;\n    toggleCollapseHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Collapse, {\n  selector: collapseSelector,\n  init: collapseInitCallback,\n  getInstance: getCollapseInstance,\n});\n\n/**\n * A global namespace for `focus` event.\n * @type {string}\n */\nconst focusEvent = 'focus';\n\n/**\n * A global namespace for `keyup` event.\n * @type {string}\n */\nconst keyupEvent = 'keyup';\n\n/**\n * A global namespace for `scroll` event.\n * @type {string}\n */\nconst scrollEvent = 'scroll';\n\n/**\n * A global namespace for `resize` event.\n * @type {string}\n */\nconst resizeEvent = 'resize';\n\n/**\n * A global namespace for `ArrowUp` key.\n * @type {string} e.which = 38 equivalent\n */\nconst keyArrowUp = 'ArrowUp';\n\n/**\n * A global namespace for `ArrowDown` key.\n * @type {string} e.which = 40 equivalent\n */\nconst keyArrowDown = 'ArrowDown';\n\n/**\n * A global namespace for `Escape` key.\n * @type {string} e.which = 27 equivalent\n */\nconst keyEscape = 'Escape';\n\n/**\n * Shortcut for `HTMLElement.hasAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {boolean} the query result\n */\nconst hasAttribute = (element, attribute) => element.hasAttribute(attribute);\n\n/**\n * Utility to focus an `HTMLElement` target.\n *\n * @param {HTMLElement} element is the target\n */\nconst focus = (element) => element.focus();\n\n/**\n * Returns the `Window` object of a target node.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {(Node | Window)=} node target node\n * @returns {Window} the `Window` object\n */\nfunction getWindow(node) {\n  // node is undefined | NULL\n  if (!node) return window;\n  // node instanceof Document\n  if (isDocument(node)) return node.defaultView;\n  // node instanceof Node\n  if (isNode(node)) return node.ownerDocument.defaultView;\n  // node is instanceof Window\n  return node;\n}\n\n/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\n\n/** @type {string} */\nconst dropdownComponent = 'Dropdown';\n\n/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = 'dropdown-menu';\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param {Node} element the target element\n * @returns {boolean} the query result\n */\nfunction isEmptyAnchor(element) {\n  // `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, 'A');\n  return isHTMLElement(element)\n    // anchor href starts with #\n    && ((hasAttribute(element, 'href') && element.href.slice(-1) === '#')\n    // OR a child of an anchor with href starts with #\n    || (parentAnchor && hasAttribute(parentAnchor, 'href')\n    && parentAnchor.href.slice(-1) === '#'));\n}\n\n/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [\n  dropdownString,\n  dropupString,\n  dropstartString,\n  dropendString,\n] = dropdownMenuClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Dropdown>}\n */\nconst getDropdownInstance = (element) => getInstance(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n * @type {BSN.InitCallback<Dropdown>}\n */\nconst dropdownInitCallback = (element) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\n// const dropdownMenuStartClass = `${dropdownMenuClass}-start`;\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = ['A', 'BUTTON'];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: 'dynamic', // [dynamic|static]\n};\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = OriginalEvent(`show.bs.${dropdownString}`);\nconst shownDropdownEvent = OriginalEvent(`shown.bs.${dropdownString}`);\nconst hideDropdownEvent = OriginalEvent(`hide.bs.${dropdownString}`);\nconst hiddenDropdownEvent = OriginalEvent(`hidden.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction styleDropdown(self) {\n  const {\n    element, menu, parentElement, options,\n  } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  /* istanbul ignore next: this test requires a navbar */\n  if (getElementStyle(menu, 'position') === 'static') return;\n\n  const RTL = isRTL(element);\n  // const menuStart = hasClass(menu, dropdownMenuStartClass);\n  const menuEnd = hasClass(menu, dropdownMenuEndClass);\n\n  // reset menu offset and position\n  const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];\n  resetProps.forEach((p) => { menu.style[p] = ''; });\n\n  // set initial position class\n  // take into account .btn-group parent as .dropdown\n  // this requires navbar/btn-group/input-group\n  let positionClass = dropdownMenuClasses.find((c) => hasClass(parentElement, c))\n    || /* istanbul ignore next: fallback position */ dropdownString;\n\n  /** @type {Record<string, Record<string, any>>} */\n  let dropdownMargin = {\n    dropdown: [offset, 0, 0],\n    dropup: [0, 0, offset],\n    dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n    dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n  };\n\n  /** @type {Record<string, Record<string, any>>} */\n  const dropdownPosition = {\n    dropdown: { top: '100%' },\n    dropup: { top: 'auto', bottom: '100%' },\n    dropstart: RTL ? { left: '100%', right: 'auto' } : { left: 'auto', right: '100%' },\n    dropend: RTL ? { left: 'auto', right: '100%' } : { left: '100%', right: 'auto' },\n    menuStart: RTL ? { right: 0, left: 'auto' } : { right: 'auto', left: 0 },\n    menuEnd: RTL ? { right: 'auto', left: 0 } : { right: 0, left: 'auto' },\n  };\n\n  const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n  const { clientWidth, clientHeight } = getDocumentElement(element);\n  const {\n    left: targetLeft, top: targetTop,\n    width: targetWidth, height: targetHeight,\n  } = getBoundingClientRect(element);\n\n  // dropstart | dropend\n  const leftFullExceed = targetLeft - menuWidth - offset < 0;\n  // dropend\n  const rightFullExceed = targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n  // dropstart | dropend\n  const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n  // dropdown\n  const bottomFullExceed = targetTop + menuHeight + targetHeight + offset >= clientHeight;\n  // dropup\n  const topExceed = targetTop - menuHeight - offset < 0;\n  // dropdown / dropup\n  const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd))\n    && targetLeft + targetWidth - menuWidth < 0;\n  const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd))\n    && targetLeft + menuWidth >= clientWidth;\n\n  // recompute position\n  // handle RTL as well\n  if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropstartString && (!RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropendString;\n  }\n  if (positionClass === dropendString && (RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropstartString;\n  }\n  if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n    positionClass = dropupString;\n  }\n\n  // override position for horizontal classes\n  if (horizontalClass.includes(positionClass) && bottomExceed) {\n    ObjectAssign(dropdownPosition[positionClass], {\n      top: 'auto', bottom: 0,\n    });\n  }\n\n  // override position for vertical classes\n  if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n    // don't realign when menu is wider than window\n    // in both RTL and non-RTL readability is KING\n    let posAjust;\n    if (!leftExceed && rightExceed && !RTL) posAjust = { left: 'auto', right: 0 };\n    if (leftExceed && !rightExceed && RTL) posAjust = { left: 0, right: 'auto' };\n    if (posAjust) ObjectAssign(dropdownPosition[positionClass], posAjust);\n  }\n\n  dropdownMargin = dropdownMargin[positionClass];\n  setElementStyle(menu, {\n    ...dropdownPosition[positionClass],\n    margin: `${dropdownMargin.map((x) => (x ? `${x}px` : x)).join(' ')}`,\n  });\n\n  // override dropdown-menu-start | dropdown-menu-end\n  if (verticalClass.includes(positionClass) && menuEnd) {\n    /* istanbul ignore else */\n    if (menuEnd) {\n      const endAdjust = (!RTL && leftExceed) || (RTL && rightExceed)\n        ? 'menuStart' : /* istanbul ignore next */'menuEnd';\n      setElementStyle(menu, dropdownPosition[endAdjust]);\n    }\n  }\n}\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n * @param {HTMLElement} menu\n * @returns {HTMLElement[]}\n */\nfunction getMenuItems(menu) {\n  return [...menu.children].map((c) => {\n    if (c && menuFocusTags.includes(c.tagName)) return c;\n    const { firstElementChild } = c;\n    if (firstElementChild && menuFocusTags.includes(firstElementChild.tagName)) {\n      return firstElementChild;\n    }\n    return null;\n  }).filter((c) => c);\n}\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction toggleDropdownDismiss(self) {\n  const { element, options } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler);\n  action(doc, focusEvent, dropdownDismissHandler);\n  action(doc, keydownEvent, dropdownPreventScroll);\n  action(doc, keyupEvent, dropdownKeyHandler);\n\n  /* istanbul ignore else */\n  if (options.display === 'dynamic') {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, dropdownLayoutHandler, passiveHandler);\n    });\n  }\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Dropdown`.\n *\n * @param {Dropdown} self the `Dropdown` instance\n * @param {boolean=} add when `true`, it will add the event listener\n */\nfunction toggleDropdownHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, dropdownClickHandler);\n}\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param {(Node | Window)=} element target\n * @returns {HTMLElement?} the query result\n */\nfunction getCurrentOpenDropdown(element) {\n  const currentParent = [...dropdownMenuClasses, 'btn-group', 'input-group']\n    .map((c) => getElementsByClassName(`${c} ${showClass}`, getDocument(element)))\n    .find((x) => x.length);\n\n  if (currentParent && currentParent.length) {\n    return [...currentParent[0].children]\n      .find((x) => hasAttribute(x, dataBsToggle));\n  }\n  return null;\n}\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param {MouseEvent} e event object\n * @this {Document}\n */\nfunction dropdownDismissHandler(e) {\n  const { target, type } = e;\n\n  /* istanbul ignore next: impossible to satisfy */\n  if (!target || !target.closest) return; // some weird FF bug #409\n\n  const element = getCurrentOpenDropdown(target);\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore next */\n  if (!self) return;\n\n  const { parentElement, menu } = self;\n\n  const hasData = closest(target, dropdownSelector) !== null;\n  const isForm = parentElement && parentElement.contains(target)\n    && (target.tagName === 'form' || closest(target, 'form') !== null);\n\n  if (type === mouseclickEvent && isEmptyAnchor(target)) {\n    e.preventDefault();\n  }\n  if (type === focusEvent\n    && (target === element || target === menu || menu.contains(target))) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (isForm || hasData) ; else if (self) {\n    self.hide();\n  }\n}\n\n/**\n * Handles `click` event listener for `Dropdown`.\n * @this {HTMLElement}\n * @param {MouseEvent} e event object\n */\nfunction dropdownClickHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.toggle();\n    /* istanbul ignore else */\n    if (target && isEmptyAnchor(target)) e.preventDefault();\n  }\n}\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n * @param {KeyboardEvent} e event object\n */\nfunction dropdownPreventScroll(e) {\n  /* istanbul ignore else */\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n}\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n * @param {KeyboardEvent} e keyboard key\n * @this {Document}\n */\nfunction dropdownKeyHandler(e) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const { activeElement } = element && getDocument(element);\n  /* istanbul ignore next: impossible to satisfy */\n  if (!self || !activeElement) return;\n  const { menu, open } = self;\n  const menuItems = getMenuItems(menu);\n\n  // arrow up & down\n  if (menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)) {\n    let idx = menuItems.indexOf(activeElement);\n    /* istanbul ignore else */\n    if (activeElement === element) {\n      idx = 0;\n    } else if (code === keyArrowUp) {\n      idx = idx > 1 ? idx - 1 : 0;\n    } else if (code === keyArrowDown) {\n      idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n    }\n    /* istanbul ignore else */\n    if (menuItems[idx]) focus(menuItems[idx]);\n  }\n\n  if (keyEscape === code && open) {\n    self.toggle();\n    focus(element);\n  }\n}\n\n/**\n * @this {globalThis}\n * @returns {void}\n */\nfunction dropdownLayoutHandler() {\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n\n  /* istanbul ignore else */\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nclass Dropdown extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target Element or string selector\n   * @param {BSN.Options.Dropdown=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const { parentElement } = element;\n\n    // set targets\n    /** @type {(Element | HTMLElement)} */\n    self.parentElement = parentElement;\n    /** @type {(Element | HTMLElement)} */\n    self.menu = querySelector(`.${dropdownMenuClass}`, parentElement);\n\n    // set initial state to closed\n    /** @type {boolean} */\n    self.open = false;\n\n    // add event listener\n    toggleDropdownHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return dropdownComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return dropdownDefaults; }\n  /* eslint-enable */\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    const self = this;\n\n    if (self.open) self.hide();\n    else self.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (open) return;\n\n    const currentElement = getCurrentOpenDropdown(element);\n    const currentInstance = currentElement && getDropdownInstance(currentElement);\n    if (currentInstance) currentInstance.hide();\n\n    // dispatch event\n    [showDropdownEvent, shownDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, showDropdownEvent);\n    if (showDropdownEvent.defaultPrevented) return;\n\n    addClass(menu, showClass);\n    addClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'true');\n\n    // change menu position\n    styleDropdown(self);\n\n    self.open = !open;\n\n    focus(element); // focus the element\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, shownDropdownEvent);\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    /* istanbul ignore next */\n    if (!open) return;\n\n    [hideDropdownEvent, hiddenDropdownEvent].forEach((e) => {\n      e.relatedTarget = element;\n    });\n    dispatchEvent(parentElement, hideDropdownEvent);\n    if (hideDropdownEvent.defaultPrevented) return;\n\n    removeClass(menu, showClass);\n    removeClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'false');\n\n    self.open = !open;\n    // only re-attach handler if the instance is not disposed\n    toggleDropdownDismiss(self);\n    dispatchEvent(parentElement, hiddenDropdownEvent);\n  }\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    const self = this;\n    if (self.open) self.hide();\n\n    toggleDropdownHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Dropdown, {\n  selector: dropdownSelector,\n  init: dropdownInitCallback,\n  getInstance: getDropdownInstance,\n});\n\n/**\n * A global namespace for aria-hidden.\n * @type {string}\n */\nconst ariaHidden = 'aria-hidden';\n\n/**\n * A global namespace for aria-modal.\n * @type {string}\n */\nconst ariaModal = 'aria-modal';\n\n/**\n * Shortcut for `HTMLElement.removeAttribute()` method.\n * @param  {HTMLElement} element target element\n * @param  {string} attribute attribute name\n * @returns {void}\n */\nconst removeAttribute = (element, attribute) => element.removeAttribute(attribute);\n\n/**\n * Returns the `document.body` or the `<body>` element.\n *\n * @param {(Node | Window)=} node\n * @returns {HTMLBodyElement}\n */\nfunction getDocumentBody(node) {\n  return getDocument(node).body;\n}\n\n/** @type {string} */\nconst modalString = 'modal';\n\n/** @type {string} */\nconst modalComponent = 'Modal';\n\n/**\n * Check if target is a `ShadowRoot`.\n *\n * @param {any} element target\n * @returns {boolean} the query result\n */\nconst isShadowRoot = (element) => (element && element.constructor.name === 'ShadowRoot')\n  || false;\n\n/**\n * Returns the `parentNode` also going through `ShadowRoot`.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {Node} node the target node\n * @returns {Node} the apropriate parent node\n */\nfunction getParentNode(node) {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  return (\n    node.assignedSlot // step into the shadow DOM of the parent of a slotted node\n    || node.parentNode // DOM Element detected\n    || (isShadowRoot(node) && node.host) // ShadowRoot detected\n    || getDocumentElement(node) // fallback\n  );\n}\n\n/**\n * Check if a target element is a `<table>`, `<td>` or `<th>`.\n * This specific check is important for determining\n * the `offsetParent` of a given element.\n *\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\nconst isTableElement = (element) => (element && ['TABLE', 'TD', 'TH'].includes(element.tagName))\n  || false;\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * When `getOffset` is *true*, it returns the `offsetParent` for tooltip/popover\n * offsets computation similar to **floating-ui**.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element the target\n * @param {boolean=} getOffset when *true* it will return an `offsetParent`\n * @returns {ParentNode | Window} the query result\n */\nfunction getElementContainer(element, getOffset) {\n  const majorBlockTags = ['HTML', 'BODY'];\n\n  if (getOffset) {\n    /** @type {any} */\n    let { offsetParent } = element;\n    const win = getWindow(element);\n\n    while (offsetParent && (isTableElement(offsetParent)\n      || (isHTMLElement(offsetParent)\n        // we must count for both fixed & sticky\n        && !['sticky', 'fixed'].includes(getElementStyle(offsetParent, 'position'))))) {\n      offsetParent = offsetParent.offsetParent;\n    }\n\n    if (!offsetParent || (majorBlockTags.includes(offsetParent.tagName)\n        || getElementStyle(offsetParent, 'position') === 'static')) {\n      offsetParent = win;\n    }\n    return offsetParent;\n  }\n\n  /** @type {ParentNode[]} */\n  const containers = [];\n  /** @type {ParentNode} */\n  let { parentNode } = element;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode);\n    /* istanbul ignore else */\n    if (!(isShadowRoot(parentNode) || !!parentNode.shadowRoot\n      || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return containers.find((c, i) => {\n    if (getElementStyle(c, 'position') !== 'relative'\n      && containers.slice(i + 1).every((r) => getElementStyle(r, 'position') === 'static')) {\n      return c;\n    }\n    return null;\n  }) || getDocumentBody(element);\n}\n\n/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = 'fixed-top';\n\n/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = 'fixed-bottom';\n\n/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = 'sticky-top';\n\n/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = 'position-sticky';\n\n/** @param {(HTMLElement | Document)=} parent */\nconst getFixedItems = (parent) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName('is-fixed', parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n * @param {HTMLElement=} element the target modal/offcanvas\n */\nfunction resetScrollbar(element) {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: '',\n    overflow: '',\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  if (fixedItems.length) {\n    fixedItems.forEach((fixed) => {\n      setElementStyle(fixed, {\n        paddingRight: '',\n        marginRight: '',\n      });\n    });\n  }\n}\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n * @param {HTMLElement=} element\n * @returns {number} the value\n */\nfunction measureScrollbar(element) {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n}\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param {HTMLElement} element the target modal/offcanvas\n * @param {boolean=} overflow body does overflow or not\n */\nfunction setScrollbar(element, overflow) {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, 'paddingRight'), 10);\n  const isOpen = getElementStyle(bd, 'overflow') === 'hidden';\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  /* istanbul ignore else */\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: 'hidden',\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    /* istanbul ignore else */\n    if (fixedItems.length) {\n      fixedItems.forEach((fixed) => {\n        const itemPadValue = getElementStyle(fixed, 'paddingRight');\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        /* istanbul ignore else */\n        if ([stickyTopClass, positionStickyClass].some((c) => hasClass(fixed, c))) {\n          const itemMValue = getElementStyle(fixed, 'marginRight');\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n}\n\n/**\n * This is a shortie for `document.createElement` method\n * which allows you to create a new `HTMLElement` for a given `tagName`\n * or based on an object with specific non-readonly attributes:\n * `id`, `className`, `textContent`, `style`, etc.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\n *\n * @param {Record<string, string> | string} param `tagName` or object\n * @return {HTMLElement} a new `HTMLElement` or `Element`\n */\nfunction createElement(param) {\n  if (!param) return null;\n\n  if (typeof param === 'string') {\n    return getDocument().createElement(param);\n  }\n\n  const { tagName } = param;\n  const attr = { ...param };\n  const newElement = createElement(tagName);\n  delete attr.tagName;\n  ObjectAssign(newElement, attr);\n  return newElement;\n}\n\n/** @type {string} */\nconst offcanvasString = 'offcanvas';\n\nconst backdropString = 'backdrop';\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement('div');\n\n/**\n * Returns the current active modal / offcancas element.\n * @param {HTMLElement=} element the context element\n * @returns {HTMLElement?} the requested element\n */\nfunction getCurrentOpen(element) {\n  return querySelector(`${modalActiveSelector},${offcanvasActiveSelector}`, getDocument(element));\n}\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n * @param {boolean=} isModal\n */\nfunction toggleOverlayType(isModal) {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach((c) => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n}\n\n/**\n * Append the overlay to DOM.\n * @param {HTMLElement} container\n * @param {boolean} hasFade\n * @param {boolean=} isModal\n */\nfunction appendOverlay(container, hasFade, isModal) {\n  toggleOverlayType(isModal);\n  container.append(overlay);\n  if (hasFade) addClass(overlay, fadeClass);\n}\n\n/**\n * Shows the overlay to the user.\n */\nfunction showOverlay() {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n}\n\n/**\n * Hides the overlay from the user.\n */\nfunction hideOverlay() {\n  removeClass(overlay, showClass);\n}\n\n/**\n * Removes the overlay from DOM.\n * @param {HTMLElement=} element\n */\nfunction removeOverlay(element) {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    overlay.remove();\n    resetScrollbar(element);\n  }\n}\n\n/**\n * @param {HTMLElement} element target\n * @returns {boolean}\n */\nfunction isVisible(element) {\n  return isHTMLElement(element)\n    && getElementStyle(element, 'visibility') !== 'hidden'\n    && element.offsetParent !== null;\n}\n\n/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true, // boolean|string\n  keyboard: true, // boolean\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Modal>}\n */\nconst getModalInstance = (element) => getInstance(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n * @type {BSN.InitCallback<Modal>}\n */\nconst modalInitCallback = (element) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = OriginalEvent(`show.bs.${modalString}`);\nconst shownModalEvent = OriginalEvent(`shown.bs.${modalString}`);\nconst hideModalEvent = OriginalEvent(`hide.bs.${modalString}`);\nconst hiddenModalEvent = OriginalEvent(`hidden.bs.${modalString}`);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction setModalScrollbar(self) {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } = element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  /* istanbul ignore else */\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = !isRTL(element) ? 'paddingRight' : /* istanbul ignore next */'paddingLeft';\n    const padStyle = {};\n    padStyle[pad] = `${scrollbarWidth}px`;\n    setElementStyle(element, padStyle);\n  }\n  setScrollbar(element, (modalOverflow || clientHeight !== scrollHeight));\n}\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleModalDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  action(element, mouseclickEvent, modalDismissHandler);\n  action(getWindow(element), resizeEvent, self.update, passiveHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler);\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Modal` instance.\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleModalHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, modalClickHandler));\n  }\n}\n\n/**\n * Executes after a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function} callback the `Modal` instance\n */\nfunction afterModalHide(self, callback) {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: '', display: '' });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  /* istanbul ignore else */\n  if (focusElement) focus(focusElement);\n\n  /* istanbul ignore else */\n  if (callback) callback();\n\n  hiddenModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, hiddenModalEvent);\n}\n\n/**\n * Executes after a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction afterModalShow(self) {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, shownModalEvent);\n}\n\n/**\n * Executes before a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction beforeModalShow(self) {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: 'block' });\n\n  setModalScrollbar(self);\n  /* istanbul ignore else */\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n}\n\n/**\n * Executes before a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {Function=} callback when `true` skip animation\n */\nfunction beforeModalHide(self, callback) {\n  const {\n    element, options, hasFade,\n  } = self;\n\n  // callback can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (options.backdrop && !callback && hasFade && hasClass(overlay, showClass)\n    && !getCurrentOpen(element)) { // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self, callback);\n  }\n}\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.toggle();\n}\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction modalKeyHandler({ code, target }) {\n  const element = querySelector(modalActiveSelector, getDocument(target));\n  const self = element && getModalInstance(element);\n\n  const { options } = self;\n  /* istanbul ignore else */\n  if (options.keyboard && code === keyEscape // the keyboard option is enabled and the key is 27\n    && hasClass(element, showClass)) { // the modal is not visible\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalDismissHandler(e) {\n  const element = this;\n  const self = getModalInstance(element);\n\n  // this timer is needed\n  /* istanbul ignore next: must have a filter */\n  if (!self || Timer.get(element)) return;\n\n  const { options, isStatic, modalDialog } = self;\n  const { backdrop } = options;\n  const { target } = e;\n\n  const selectedText = getDocument(element).getSelection().toString().length;\n  const targetInsideDialog = modalDialog.contains(target);\n  const dismiss = target && closest(target, modalDismissSelector);\n\n  /* istanbul ignore else */\n  if (isStatic && !targetInsideDialog) {\n    Timer.set(element, () => {\n      addClass(element, modalStaticClass);\n      emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n    }, 17);\n  } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)) {\n    self.relatedTarget = dismiss || null;\n    self.hide();\n    e.preventDefault();\n  }\n}\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction staticTransitionEnd(self) {\n  const { element, modalDialog } = self;\n  const duration = getElementTransitionDuration(modalDialog) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n}\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nclass Modal extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually the `.modal` element\n   * @param {BSN.Options.Modal=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n\n    // the modal\n    const { element } = self;\n\n    // the modal-dialog\n    /** @type {(HTMLElement)} */\n    self.modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    // modal can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(modalToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional internals\n    /** @type {boolean} */\n    self.isStatic = self.options.backdrop === 'static';\n    /** @type {boolean} */\n    self.hasFade = hasClass(element, fadeClass);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n\n    // attach event listeners\n    toggleModalHandler(self, true);\n\n    // bind\n    self.update = self.update.bind(self);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return modalComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return modalDefaults; }\n  /* eslint-enable */\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, hasFade, relatedTarget, container,\n    } = self;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, showModalEvent);\n    if (showModalEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getModalInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Offcanvas');\n      that1.hide();\n    }\n\n    if (backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, hasFade, true);\n      } else {\n        toggleOverlayType(true);\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n\n      showOverlay();\n      setTimeout(() => beforeModalShow(self), overlayDelay);\n    } else {\n      beforeModalShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hide the modal from the user.\n   * @param {Function=} callback when defined it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const {\n      element, hasFade, relatedTarget,\n    } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, hideModalEvent);\n    if (hideModalEvent.defaultPrevented) return;\n    removeClass(element, showClass);\n    setAttribute(element, ariaHidden, 'true');\n    removeAttribute(element, ariaModal);\n\n    // if (hasFade && callback) {\n    /* istanbul ignore else */\n    if (hasFade) {\n      emulateTransitionEnd(element, () => beforeModalHide(self, callback));\n    } else {\n      beforeModalHide(self, callback);\n    }\n  }\n\n  /**\n   * Updates the modal layout.\n   * @this {Modal} the modal instance\n   */\n  update() {\n    const self = this;\n    /* istanbul ignore else */\n    if (hasClass(self.element, showClass)) setModalScrollbar(self);\n  }\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const self = this;\n    toggleModalHandler(self);\n    // use callback\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Modal, {\n  selector: modalSelector,\n  init: modalInitCallback,\n  getInstance: getModalInstance,\n});\n\n/** @type {string} */\nconst offcanvasComponent = 'Offcanvas';\n\n/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Offcanvas>}\n */\nconst getOffcanvasInstance = (element) => getInstance(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n * @type {BSN.InitCallback<Offcanvas>}\n */\nconst offcanvasInitCallback = (element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = OriginalEvent(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = OriginalEvent(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = OriginalEvent(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = OriginalEvent(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction setOffCanvasScrollbar(self) {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n}\n\n/**\n * Toggles on/off the `click` event listeners.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true*, listeners are added\n */\nfunction toggleOffcanvasEvents(self, add) {\n  const action = add ? addListener : removeListener;\n  self.triggers.forEach((btn) => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n}\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true* listeners are added\n */\nfunction toggleOffCanvasDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n}\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction beforeOffcanvasShow(self) {\n  const { element, options } = self;\n\n  /* istanbul ignore else */\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n}\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function=} callback the hide callback\n */\nfunction beforeOffcanvasHide(self, callback) {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self, callback));\n  } else hideOffcanvasComplete(self, callback);\n}\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasTriggerHandler(e) {\n  const trigger = closest(this, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  /* istanbul ignore else */\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    /* istanbul ignore else */\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n}\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasDismissHandler(e) {\n  const { target } = e;\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element);\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must have a filter */\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { backdrop } = options;\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  if (overlay.contains(target) && backdrop === 'static') return;\n\n  /* istanbul ignore else */\n  if (!(selection && selection.toString().length)\n    && ((!element.contains(target) && backdrop\n    && /* istanbul ignore next */(!trigger || triggers.includes(target)))\n    || (offCanvasDismiss && offCanvasDismiss.contains(target)))) {\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss : null;\n    self.hide();\n  }\n\n  /* istanbul ignore next */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction offcanvasKeyDismissHandler({ code, target }) {\n  const element = querySelector(offcanvasActiveSelector, getDocument(target));\n\n  const self = getOffcanvasInstance(element);\n\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n\n  /* istanbul ignore else */\n  if (self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction showOffcanvasComplete(self) {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n}\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {Function} callback the hide callback\n */\nfunction hideOffcanvasComplete(self, callback) {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find((x) => isVisible(x));\n  /* istanbul ignore else */\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n  // callback\n  if (callback) callback();\n}\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nclass Offcanvas extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target usually an `.offcanvas` element\n   * @param {BSN.Options.Offcanvas=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    const self = this;\n\n    // instance element\n    const { element } = self;\n\n    // all the triggering buttons\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(offcanvasToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional instance property\n    /** @type {HTMLBodyElement | HTMLElement} */\n    self.container = getElementContainer(element);\n    /** @type {HTMLElement?} */\n    self.relatedTarget = null;\n\n    // attach event listeners\n    toggleOffcanvasEvents(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return offcanvasComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return offcanvasDefaults; }\n  /* eslint-enable */\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, container, relatedTarget,\n    } = self;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget;\n    shownOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, showOffcanvasEvent);\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getOffcanvasInstance(currentOpen);\n      const that1 = this1\n        || /* istanbul ignore next */getInstance(currentOpen, 'Modal');\n      that1.hide();\n    }\n\n    if (options.backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, true);\n      } else {\n        toggleOverlayType();\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(self), overlayDelay);\n    } else {\n      beforeOffcanvasShow(self);\n      /* istanbul ignore else */\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hides the offcanvas from the user.\n   * @param {Function=} callback when `true` it will skip animation\n   */\n  hide(callback) {\n    const self = this;\n    const { element, relatedTarget } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, hideOffcanvasEvent);\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n\n    if (!callback) {\n      emulateTransitionEnd(element, () => beforeOffcanvasHide(self, callback));\n    } else beforeOffcanvasHide(self, callback);\n  }\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const self = this;\n    toggleOffcanvasEvents(self);\n    self.hide(() => super.dispose());\n  }\n}\n\nObjectAssign(Offcanvas, {\n  selector: offcanvasSelector,\n  init: offcanvasInitCallback,\n  getInstance: getOffcanvasInstance,\n});\n\n/** @type {string} */\nconst popoverString = 'popover';\n\n/** @type {string} */\nconst popoverComponent = 'Popover';\n\n/** @type {string} */\nconst tooltipString = 'tooltip';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param {string} tipType the expected markup type\n * @returns {string} the template markup\n */\nfunction getTipTemplate(tipType) {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n}\n\n/**\n * Checks if an element is an `<svg>` (or any type of SVG element),\n * `<img>` or `<video>`.\n *\n * *Tooltip* / *Popover* works different with media elements.\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\n\nconst isMedia = (element) => (\n  element\n  && element.nodeType === 1\n  && ['SVG', 'Image', 'Video'].some((s) => element.constructor.name.includes(s))) || false;\n\n/**\n * Returns an `{x,y}` object with the target\n * `HTMLElement` / `Node` scroll position.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Window} element target node / element\n * @returns {{x: number, y: number}} the scroll tuple\n */\nfunction getNodeScroll(element) {\n  const isWin = 'scrollX' in element;\n  const x = isWin ? element.scrollX : element.scrollLeft;\n  const y = isWin ? element.scrollY : element.scrollTop;\n\n  return { x, y };\n}\n\n/**\n * Checks if a target `HTMLElement` is affected by scale.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @returns {boolean} the query result\n */\nfunction isScaledElement(element) {\n  if (!element || !isHTMLElement(element)) return false;\n  const { width, height } = getBoundingClientRect(element);\n  const { offsetWidth, offsetHeight } = element;\n  return Math.round(width) !== offsetWidth\n    || Math.round(height) !== offsetHeight;\n}\n\n/**\n * Returns the rect relative to an offset parent.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @param {ParentNode | Window} offsetParent the container / offset parent\n * @param {{x: number, y: number}} scroll the offsetParent scroll position\n * @returns {SHORTY.OffsetRect}\n */\nfunction getRectRelativeToOffsetParent(element, offsetParent, scroll) {\n  const isParentAnElement = isHTMLElement(offsetParent);\n  const rect = getBoundingClientRect(element, isParentAnElement && isScaledElement(offsetParent));\n  const offsets = { x: 0, y: 0 };\n\n  /* istanbul ignore next */\n  if (isParentAnElement) {\n    const offsetRect = getBoundingClientRect(offsetParent, true);\n    offsets.x = offsetRect.x + offsetParent.clientLeft;\n    offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n\n  return {\n    x: rect.left + scroll.x - offsets.x,\n    y: rect.top + scroll.y - offsets.y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/** @type {Record<string, string>} */\nconst tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\n/**\n * Style popovers and tooltips.\n * @param {BSN.Tooltip | BSN.Popover} self the `Popover` / `Tooltip` instance\n * @param {PointerEvent=} e event object\n */\nfunction styleTip(self, e) {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const {\n    element, tooltip, options, arrow, offsetParent,\n  } = self;\n  const tipPositions = { ...tipClassPositions };\n\n  const RTL = isRTL(element);\n  if (RTL) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // reset tooltip style (top: 0, left: 0 works best)\n  setElementStyle(tooltip, {\n    // top: '0px', left: '0px', right: '', bottom: '',\n    top: '', left: '', right: '', bottom: '',\n  });\n  const isPopover = self.name === popoverComponent;\n  const {\n    offsetWidth: tipWidth, offsetHeight: tipHeight,\n  } = tooltip;\n  const {\n    clientWidth: htmlcw, clientHeight: htmlch,\n  } = getDocumentElement(element);\n  const { container } = options;\n  let { placement } = options;\n  const {\n    left: parentLeft, right: parentRight, top: parentTop,\n  } = getBoundingClientRect(container, true);\n  const {\n    clientWidth: parentCWidth, offsetWidth: parentOWidth,\n  } = container;\n  const scrollbarWidth = Math.abs(parentCWidth - parentOWidth);\n  // const tipAbsolute = getElementStyle(tooltip, 'position') === 'absolute';\n  const parentPosition = getElementStyle(container, 'position');\n  // const absoluteParent = parentPosition === 'absolute';\n  const fixedParent = parentPosition === 'fixed';\n  const staticParent = parentPosition === 'static';\n  const stickyParent = parentPosition === 'sticky';\n  const isSticky = stickyParent && parentTop === parseFloat(getElementStyle(container, 'top'));\n  // const absoluteTarget = getElementStyle(element, 'position') === 'absolute';\n  // const stickyFixedParent = ['sticky', 'fixed'].includes(parentPosition);\n  const leftBoundry = RTL && fixedParent ? scrollbarWidth : 0;\n  const rightBoundry = fixedParent ? parentCWidth + parentLeft + (RTL ? scrollbarWidth : 0)\n    : parentCWidth + parentLeft + (htmlcw - parentRight) - 1;\n  const {\n    width: elemWidth,\n    height: elemHeight,\n    left: elemRectLeft,\n    right: elemRectRight,\n    top: elemRectTop,\n  } = getBoundingClientRect(element, true);\n\n  const scroll = getNodeScroll(offsetParent);\n  const { x, y } = getRectRelativeToOffsetParent(element, offsetParent, scroll);\n  // reset arrow style\n  setElementStyle(arrow, {\n    top: '', left: '', right: '', bottom: '',\n  });\n  let topPosition;\n  let leftPosition;\n  let rightPosition;\n  let arrowTop;\n  let arrowLeft;\n  let arrowRight;\n\n  const arrowWidth = arrow.offsetWidth || 0;\n  const arrowHeight = arrow.offsetHeight || 0;\n  const arrowAdjust = arrowWidth / 2;\n\n  // check placement\n  let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n  let bottomExceed = elemRectTop + tipHeight + elemHeight\n    + arrowHeight >= htmlch;\n  let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n  let rightExceed = elemRectLeft + tipWidth + elemWidth\n    + arrowWidth >= rightBoundry;\n\n  const horizontal = ['left', 'right'];\n  const vertical = ['top', 'bottom'];\n\n  topExceed = horizontal.includes(placement)\n    ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n    : topExceed;\n  bottomExceed = horizontal.includes(placement)\n    ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= htmlch\n    : bottomExceed;\n  leftExceed = vertical.includes(placement)\n    ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry\n    : leftExceed;\n  rightExceed = vertical.includes(placement)\n    ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n    : rightExceed;\n\n  // first remove side positions if both left and right limits are exceeded\n  // we usually fall back to top|bottom\n  placement = (horizontal.includes(placement)) && leftExceed && rightExceed ? 'top' : placement;\n  // second, recompute placement\n  placement = placement === 'top' && topExceed ? 'bottom' : placement;\n  placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n  placement = placement === 'left' && leftExceed ? 'right' : placement;\n  placement = placement === 'right' && rightExceed ? 'left' : placement;\n\n  // update tooltip/popover class\n  if (!tooltip.className.includes(placement)) {\n    tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n  }\n\n  // compute tooltip / popover coordinates\n  /* istanbul ignore else */\n  if (horizontal.includes(placement)) { // secondary|side positions\n    if (placement === 'left') { // LEFT\n      leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n    } else { // RIGHT\n      leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n    }\n\n    // adjust top and arrow\n    if (topExceed) {\n      topPosition = y;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = elemHeight / 2 - arrowWidth;\n    } else if (bottomExceed) {\n      topPosition = y - tipHeight + elemHeight;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n    } else {\n      topPosition = y - tipHeight / 2 + elemHeight / 2;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight / 2 - arrowHeight / 2;\n    }\n  } else if (vertical.includes(placement)) {\n    if (e && isMedia(element)) {\n      let eX = 0;\n      let eY = 0;\n      if (staticParent) {\n        eX = e.pageX;\n        eY = e.pageY;\n      } else { // fixedParent | stickyParent\n        eX = e.clientX - parentLeft + (fixedParent ? scroll.x : 0);\n        eY = e.clientY - parentTop + (fixedParent ? scroll.y : 0);\n      }\n\n      // some weird RTL bug\n      eX -= RTL && fixedParent && scrollbarWidth ? scrollbarWidth : 0;\n\n      if (placement === 'top') {\n        topPosition = eY - tipHeight - arrowWidth;\n      } else {\n        topPosition = eY + arrowWidth;\n      }\n\n      // adjust (left | right) and also the arrow\n      if (e.clientX - tipWidth / 2 < leftBoundry) {\n        leftPosition = 0;\n        arrowLeft = eX - arrowAdjust;\n      } else if (e.clientX + tipWidth / 2 > rightBoundry) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = rightBoundry - eX - arrowAdjust;\n        arrowRight -= fixedParent ? parentLeft + (RTL ? scrollbarWidth : 0) : 0;\n\n      // normal top/bottom\n      } else {\n        leftPosition = eX - tipWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    } else {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else { // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n  }\n\n  // apply style to tooltip/popover\n  setElementStyle(tooltip, {\n    top: `${topPosition}px`,\n    left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n    right: rightPosition !== undefined ? `${rightPosition}px` : '',\n  });\n\n  // update arrow placement\n  /* istanbul ignore else */\n  if (isHTMLElement(arrow)) {\n    if (arrowTop !== undefined) {\n      arrow.style.top = `${arrowTop}px`;\n    }\n    if (arrowLeft !== undefined) {\n      arrow.style.left = `${arrowLeft}px`;\n    } else if (arrowRight !== undefined) {\n      arrow.style.right = `${arrowRight}px`;\n    }\n  }\n}\n\nconst tooltipDefaults = {\n  /** @type {string} */\n  template: getTipTemplate(tooltipString),\n  /** @type {string?} */\n  title: null, // string\n  /** @type {string?} */\n  customClass: null, // string | null\n  /** @type {string} */\n  trigger: 'hover focus',\n  /** @type {string?} */\n  placement: 'top', // string\n  /** @type {((c:string)=>string)?} */\n  sanitizeFn: null, // function\n  /** @type {boolean} */\n  animation: true, // bool\n  /** @type {number} */\n  delay: 200, // number\n  /** @type {HTMLElement?} */\n  container: null,\n};\n\n/**\n * A global namespace for aria-describedby.\n * @type {string}\n */\nconst ariaDescribedBy = 'aria-describedby';\n\n/**\n * A global namespace for `mousedown` event.\n * @type {string}\n */\nconst mousedownEvent = 'mousedown';\n\n/**\n * A global namespace for `mousemove` event.\n * @type {string}\n */\nconst mousemoveEvent = 'mousemove';\n\n/**\n * A global namespace for `focusin` event.\n * @type {string}\n */\nconst focusinEvent = 'focusin';\n\n/**\n * A global namespace for `focusout` event.\n * @type {string}\n */\nconst focusoutEvent = 'focusout';\n\n/**\n * A global namespace for `hover` event.\n * @type {string}\n */\nconst mousehoverEvent = 'hover';\n\n/**\n * A global namespace for `touchstart` event.\n * @type {string}\n */\nconst touchstartEvent = 'touchstart';\n\nlet elementUID = 0;\nlet elementMapUID = 0;\nconst elementIDMap = new Map();\n\n/**\n * Returns a unique identifier for popover, tooltip, scrollspy.\n *\n * @param {HTMLElement} element target element\n * @param {string=} key predefined key\n * @returns {number} an existing or new unique ID\n */\nfunction getUID(element, key) {\n  let result = key ? elementUID : elementMapUID;\n\n  if (key) {\n    const elID = getUID(element);\n    const elMap = elementIDMap.get(elID) || new Map();\n    if (!elementIDMap.has(elID)) {\n      elementIDMap.set(elID, elMap);\n    }\n    if (!elMap.has(key)) {\n      elMap.set(key, result);\n      elementUID += 1;\n    } else result = elMap.get(key);\n  } else {\n    const elkey = element.id || element;\n\n    if (!elementIDMap.has(elkey)) {\n      elementIDMap.set(elkey, result);\n      elementMapUID += 1;\n    } else result = elementIDMap.get(elkey);\n  }\n  return result;\n}\n\n/**\n * Checks if an object is a `Function`.\n *\n * @param {any} fn the target object\n * @returns {boolean} the query result\n */\nconst isFunction = (fn) => (fn && fn.constructor.name === 'Function') || false;\n\nconst { userAgentData: uaDATA } = navigator;\n\n/**\n * A global namespace for `userAgentData` object.\n */\nconst userAgentData = uaDATA;\n\nconst { userAgent: userAgentString } = navigator;\n\n/**\n * A global namespace for `navigator.userAgent` string.\n */\nconst userAgent = userAgentString;\n\nconst appleBrands = /(iPhone|iPod|iPad)/;\n\n/**\n * A global `boolean` for Apple browsers.\n * @type {boolean}\n */\nconst isApple = userAgentData ? userAgentData.brands.some((x) => appleBrands.test(x.brand))\n  : /* istanbul ignore next */appleBrands.test(userAgent);\n\n/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\n\n/** @type {string} */\nconst tooltipComponent = 'Tooltip';\n\n/**\n * Checks if an object is a `NodeList`.\n * => equivalent to `object instanceof NodeList`\n *\n * @param {any} object the target object\n * @returns {boolean} the query result\n */\nconst isNodeList = (object) => (object && object.constructor.name === 'NodeList') || false;\n\n/**\n * Shortcut for `typeof SOMETHING === \"string\"`.\n *\n * @param  {any} str input value\n * @returns {boolean} the query result\n */\nconst isString = (str) => typeof str === 'string';\n\n/**\n * Shortcut for `Array.isArray()` static method.\n *\n * @param  {any} arr array-like iterable object\n * @returns {boolean} the query result\n */\nconst isArray = (arr) => Array.isArray(arr);\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param {HTMLElement} element target\n * @param {Node | string} content the `Element` to append / string\n * @param {ReturnType<any>} sanitizeFn a function to sanitize string content\n */\nfunction setHtml(element, content, sanitizeFn) {\n  /* istanbul ignore next */\n  if (!isHTMLElement(element) || (isString(content) && !content.length)) return;\n\n  /* istanbul ignore else */\n  if (isString(content)) {\n    let dirty = content.trim(); // fixing #233\n    if (isFunction(sanitizeFn)) dirty = sanitizeFn(dirty);\n\n    const win = getWindow(element);\n    const domParser = new win.DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    element.append(...[...tempDocument.body.childNodes]);\n  } else if (isHTMLElement(content)) {\n    element.append(content);\n  } else if (isNodeList(content)\n    || (isArray(content) && content.every(isNode))) {\n    element.append(...[...content]);\n  }\n}\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param {BSN.Popover | BSN.Tooltip} self the `Tooltip` / `Popover` instance\n */\nfunction createTip(self) {\n  const { id, element, options } = self;\n  const {\n    animation, customClass, sanitizeFn, placement, dismissible,\n    title, content, template, btnClose,\n  } = options;\n  const isTooltip = self.name === tooltipComponent;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const tipPositions = { ...tipClassPositions };\n  let titleParts = [];\n  let contentParts = [];\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  /** @type {HTMLElement?} */\n  let tooltipTemplate;\n  if (isHTMLElement(template)) {\n    tooltipTemplate = template;\n  } else {\n    const htmlMarkup = createElement('div');\n    setHtml(htmlMarkup, template, sanitizeFn);\n    tooltipTemplate = htmlMarkup.firstChild;\n  }\n\n  // set popover markup\n  self.tooltip = isHTMLElement(tooltipTemplate) && tooltipTemplate.cloneNode(true);\n\n  const { tooltip } = self;\n\n  // set id and role attributes\n  setAttribute(tooltip, 'id', id);\n  setAttribute(tooltip, 'role', tooltipString);\n\n  const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n  const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n  const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n  // set arrow and enable access for styleTip\n  self.arrow = querySelector(`.${tipString}-arrow`, tooltip);\n  const { arrow } = self;\n\n  if (isHTMLElement(title)) titleParts = [title.cloneNode(true)];\n  else {\n    const tempTitle = createElement('div');\n    setHtml(tempTitle, title, sanitizeFn);\n    titleParts = [...[...tempTitle.childNodes]];\n  }\n\n  if (isHTMLElement(content)) contentParts = [content.cloneNode(true)];\n  else {\n    const tempContent = createElement('div');\n    setHtml(tempContent, content, sanitizeFn);\n    contentParts = [...[...tempContent.childNodes]];\n  }\n\n  // set dismissible button\n  if (dismissible) {\n    if (title) {\n      if (isHTMLElement(btnClose)) titleParts = [...titleParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        titleParts = [...titleParts, tempBtn.firstChild];\n      }\n    } else {\n      /* istanbul ignore else */\n      if (tooltipHeader) tooltipHeader.remove();\n      if (isHTMLElement(btnClose)) contentParts = [...contentParts, btnClose.cloneNode(true)];\n      else {\n        const tempBtn = createElement('div');\n        setHtml(tempBtn, btnClose, sanitizeFn);\n        contentParts = [...contentParts, tempBtn.firstChild];\n      }\n    }\n  }\n\n  // fill the template with content from options / data attributes\n  // also sanitize title && content\n  /* istanbul ignore else */\n  if (!isTooltip) {\n    /* istanbul ignore else */\n    if (title && tooltipHeader) setHtml(tooltipHeader, titleParts, sanitizeFn);\n    /* istanbul ignore else */\n    if (content && tooltipBody) setHtml(tooltipBody, contentParts, sanitizeFn);\n    // set btn\n    self.btn = querySelector('.btn-close', tooltip);\n  } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n  // Bootstrap 5.2.x\n  addClass(tooltip, 'position-absolute');\n  addClass(arrow, 'position-absolute');\n\n  // set popover animation and placement\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n  /* istanbul ignore else */\n  if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n  /* istanbul ignore else */\n  if (customClass && !hasClass(tooltip, customClass)) {\n    addClass(tooltip, customClass);\n  }\n  /* istanbul ignore else */\n  if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n}\n\n/**\n * @param {HTMLElement} tip target\n * @param {ParentNode} container parent container\n * @returns {boolean}\n */\nfunction isVisibleTip(tip, container) {\n  return isHTMLElement(tip) && container.contains(tip);\n}\n\n/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tooltip>}\n */\nlet getTooltipInstance = (element) => getInstance(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n * @type {BSN.InitCallback<Tooltip>}\n */\nconst tooltipInitCallback = (element) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction removeTooltip(self) {\n  const { element, tooltip } = self;\n  removeAttribute(element, ariaDescribedBy);\n  tooltip.remove();\n}\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the parent dispose callback\n */\nfunction disposeTooltipComplete(self, callback) {\n  const { element } = self;\n  toggleTooltipHandlers(self);\n\n  /* istanbul ignore else */\n  if (hasAttribute(element, dataOriginalTitle) && self.name === tooltipComponent) {\n    toggleTooltipTitle(self);\n  }\n  /* istanbul ignore else */\n  if (callback) callback();\n}\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipAction(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      action(getWindow(element), ev, self.update, passiveHandler);\n    });\n  }\n}\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction tooltipShownAction(self) {\n  const { element } = self;\n  const shownTooltipEvent = OriginalEvent(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n}\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {Function=} callback the dispose callback\n */\nfunction tooltipHiddenAction(self, callback) {\n  const { element } = self;\n  const hiddenTooltipEvent = OriginalEvent(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n  if (isFunction(callback)) callback();\n  Timer.clear(element, 'out');\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  // btn is only for dismissible popover\n  const { element, options, btn } = self;\n  const { trigger, dismissible } = options;\n\n  if (trigger.includes('manual')) return;\n\n  self.enabled = !!add;\n\n  /** @type {string[]} */\n  const triggerOptions = trigger.split(' ');\n  const elemIsMedia = isMedia(element);\n\n  if (elemIsMedia) {\n    action(element, mousemoveEvent, self.update, passiveHandler);\n  }\n\n  triggerOptions.forEach((tr) => {\n    /* istanbul ignore else */\n    if (elemIsMedia || tr === mousehoverEvent) {\n      action(element, mousedownEvent, self.show);\n      action(element, mouseenterEvent, self.show);\n\n      /* istanbul ignore else */\n      if (dismissible && btn) {\n        action(btn, mouseclickEvent, self.hide);\n      } else {\n        action(element, mouseleaveEvent, self.hide);\n        action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n      }\n    } else if (tr === mouseclickEvent) {\n      action(element, tr, (!dismissible ? self.toggle : self.show));\n    } else if (tr === focusEvent) {\n      action(element, focusinEvent, self.show);\n      /* istanbul ignore else */\n      if (!dismissible) action(element, focusoutEvent, self.hide);\n      /* istanbul ignore else */\n      if (isApple) {\n        action(element, mouseclickEvent, () => focus(element));\n      }\n    }\n  });\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipOpenHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element, options, offsetParent } = self;\n  const { container } = options;\n  const { offsetHeight, scrollHeight } = container;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  /* istanbul ignore else */\n  if (!isMedia(element)) {\n    const win = getWindow(element);\n    const overflow = offsetHeight !== scrollHeight;\n    const scrollTarget = overflow || offsetParent !== win ? container : win;\n    action(win, resizeEvent, self.update, passiveHandler);\n    action(scrollTarget, scrollEvent, self.update, passiveHandler);\n  }\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.hide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.hide);\n}\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {string=} content when `true`, event listeners are added\n */\nfunction toggleTooltipTitle(self, content) {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(element, titleAtt[content ? 0 : 1],\n    (content || getAttribute(element, titleAtt[0])));\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n}\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nclass Tooltip extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Tooltip=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n    const { element } = self;\n    const isTooltip = self.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    /* istanbul ignore next: this is to set Popover too */\n    getTooltipInstance = (elem) => getInstance(elem, tipComponent);\n\n    // additional properties\n    /** @type {any} */\n    self.tooltip = {};\n    if (!isTooltip) {\n      /** @type {any?} */\n      self.btn = null;\n    }\n    /** @type {any} */\n    self.arrow = {};\n    /** @type {any} */\n    self.offsetParent = {};\n    /** @type {boolean} */\n    self.enabled = true;\n    /** @type {string} Set unique ID for `aria-describedby`. */\n    self.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = self;\n\n    // invalidate\n    if ((!options.title && isTooltip) || (!isTooltip && !options.content)) {\n      // throw Error(`${this.name} Error: target has no content set.`);\n      return;\n    }\n\n    const container = querySelector(options.container, getDocument(element));\n    const idealContainer = getElementContainer(element);\n\n    // bypass container option when its position is static/relative\n    self.options.container = !container || (container\n      && ['static', 'relative'].includes(getElementStyle(container, 'position')))\n      ? idealContainer\n      : /* istanbul ignore next */container || getDocumentBody(element);\n\n    // reset default options\n    tooltipDefaults[titleAttr] = null;\n\n    // all functions bind\n    self.handleTouch = self.handleTouch.bind(self);\n    self.update = self.update.bind(self);\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n    self.toggle = self.toggle.bind(self);\n\n    // set title attributes and add event listeners\n    /* istanbul ignore else */\n    if (hasAttribute(element, titleAttr) && isTooltip) {\n      toggleTooltipTitle(self, options.title);\n    }\n\n    // create tooltip here\n    createTip(self);\n\n    // attach events\n    toggleTooltipHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return tooltipComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return tooltipDefaults; }\n  /* eslint-enable */\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /**\n   * Shows the tooltip.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip}\n   */\n  show(e) {\n    const self = this;\n    const {\n      options, tooltip, element, id,\n    } = self;\n    const { container, animation } = options;\n    const outTimer = Timer.get(element, 'out');\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const showTooltipEvent = OriginalEvent(`show.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, showTooltipEvent);\n        if (showTooltipEvent.defaultPrevented) return;\n\n        // append to container\n        container.append(tooltip);\n        setAttribute(element, ariaDescribedBy, `#${id}`);\n        // set offsetParent\n        self.offsetParent = getElementContainer(tooltip, true);\n\n        self.update(e);\n        toggleTooltipOpenHandlers(self, true);\n\n        /* istanbul ignore else */\n        if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(self));\n        else tooltipShownAction(self);\n      }, 17, 'in');\n    }\n  }\n\n  /**\n   * Hides the tooltip.\n   *\n   * @this {Tooltip} the Tooltip instance\n   * @param {Function=} callback the dispose callback\n   */\n  hide(callback) {\n    const self = this;\n    const { options, tooltip, element } = self;\n    const { container, animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    /* istanbul ignore else */\n    if (tooltip && isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const hideTooltipEvent = OriginalEvent(`hide.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, hideTooltipEvent);\n\n        if (hideTooltipEvent.defaultPrevented) return;\n\n        removeClass(tooltip, showClass);\n        toggleTooltipOpenHandlers(self);\n\n        /* istanbul ignore else */\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(self, callback));\n        else tooltipHiddenAction(self, callback);\n      }, delay + 17, 'out');\n    }\n  }\n\n  /**\n   * Updates the tooltip position.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the `Tooltip` instance\n   */\n  update(e) {\n    styleTip(this, e);\n  }\n\n  /**\n   * Toggles the tooltip visibility.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the instance\n   */\n  toggle(e) {\n    const self = this;\n    const { tooltip, options } = self;\n\n    if (!isVisibleTip(tooltip, options.container)) self.show(e);\n    else self.hide();\n  }\n\n  /** Enables the tooltip. */\n  enable() {\n    const self = this;\n    const { enabled } = self;\n    /* istanbul ignore else */\n    if (!enabled) {\n      toggleTooltipHandlers(self, true);\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const self = this;\n    const {\n      tooltip, options, enabled,\n    } = self;\n    const { animation, container } = options;\n    /* istanbul ignore else */\n    if (enabled) {\n      if (isVisibleTip(tooltip, container) && animation) {\n        self.hide(() => toggleTooltipHandlers(self));\n      } else {\n        toggleTooltipHandlers(self);\n      }\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    const self = this;\n    if (!self.enabled) self.enable();\n    else self.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch({ target }) {\n    const { tooltip, element } = this;\n\n    /* istanbul ignore next */\n    if (tooltip.contains(target) || target === element\n      || (target && element.contains(target))) ; else {\n      this.hide();\n    }\n  }\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const self = this;\n    const { tooltip, options } = self;\n    const callback = () => disposeTooltipComplete(self, () => super.dispose());\n\n    if (options.animation && isVisibleTip(tooltip, options.container)) {\n      self.options.delay = 0; // reset delay\n      self.hide(callback);\n    } else {\n      callback();\n    }\n  }\n}\n\nObjectAssign(Tooltip, {\n  selector: tooltipSelector,\n  init: tooltipInitCallback,\n  getInstance: getTooltipInstance,\n  styleTip,\n});\n\n/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector = `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults = {\n  ...tooltipDefaults,\n  /** @type {string} */\n  template: getTipTemplate(popoverString),\n  /** @type {string} */\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n  /** @type {boolean} */\n  dismissible: false,\n  /** @type {string?} */\n  content: null,\n};\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nclass Popover extends Tooltip {\n  /* eslint-disable -- we want to specify Popover Options */\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.Popover=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   */ \n  get name() { return popoverComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return popoverDefaults; }\n  /* eslint-enable */\n\n  /* extend original `show()` */\n  show() {\n    super.show();\n    // btn only exists within dismissible popover\n    const { options, btn } = this;\n    /* istanbul ignore else */\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  }\n}\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Popover>}\n */\nconst getPopoverInstance = (element) => getInstance(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n * @type {BSN.InitCallback<Popover>}\n */\nconst popoverInitCallback = (element) => new Popover(element);\n\nObjectAssign(Popover, {\n  selector: popoverSelector,\n  init: popoverInitCallback,\n  getInstance: getPopoverInstance,\n  styleTip,\n});\n\n/**\n * Shortcut for `HTMLElement.getElementsByTagName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByTagName`.\n *\n * @param {string} selector the tag name\n * @param {ParentNode=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement>} the 'HTMLCollection'\n */\nfunction getElementsByTagName(selector, parent) {\n  const lookUp = isNode(parent) ? parent : getDocument();\n  return lookUp.getElementsByTagName(selector);\n}\n\n/** @type {string} */\nconst scrollspyString = 'scrollspy';\n\n/** @type {string} */\nconst scrollspyComponent = 'ScrollSpy';\n\n/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults = {\n  offset: 10,\n  target: null,\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<ScrollSpy>}\n */\nconst getScrollSpyInstance = (element) => getInstance(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n * @type {BSN.InitCallback<ScrollSpy>}\n */\nconst scrollspyInitCallback = (element) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = OriginalEvent(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n */\nfunction updateSpyTargets(self) {\n  const {\n    target, scrollTarget, options, itemsLength, scrollHeight, element,\n  } = self;\n  const { offset } = options;\n  const isWin = isWindow(scrollTarget);\n\n  const links = target && getElementsByTagName('A', target);\n  const scrollHEIGHT = scrollTarget && getScrollHeight(scrollTarget);\n\n  self.scrollTop = isWin ? scrollTarget.scrollY : scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  /* istanbul ignore else */\n  if (links && (itemsLength !== links.length || scrollHEIGHT !== scrollHeight)) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    [...links].forEach((link) => {\n      href = getAttribute(link, 'href');\n      targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#'\n        && querySelector(href, getDocument(element));\n\n      if (targetItem) {\n        self.items.push(link);\n        rect = getBoundingClientRect(targetItem);\n        self.offsets.push((isWin ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n}\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n * @param {Node | Window} scrollTarget the `ScrollSpy` instance\n * @return {number} `scrollTarget` height\n */\nfunction getScrollHeight(scrollTarget) {\n  return isHTMLElement(scrollTarget)\n    ? scrollTarget.scrollHeight\n    : getDocumentElement(scrollTarget).scrollHeight;\n}\n\n/**\n * Returns the height property of the scrolling element.\n * @param {ScrollSpy} params the `ScrollSpy` instance\n * @returns {number}\n */\nfunction getOffsetHeight({ element, scrollTarget }) {\n  return (isWindow(scrollTarget))\n    ? scrollTarget.innerHeight\n    : getBoundingClientRect(element).height;\n}\n\n/**\n * Clear all items of the target.\n * @param {HTMLElement} target a single item\n */\nfunction clear(target) {\n  [...getElementsByTagName('A', target)].forEach((item) => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n}\n\n/**\n * Activates a new item.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {HTMLElement} item a single item\n */\nfunction activate(self, item) {\n  const { target, element } = self;\n  clear(target);\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    parentItem = parentItem.parentElement;\n    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);\n  }\n\n  parents.forEach((menuItem) => {\n    /** @type {HTMLElement?} */\n    const parentLink = menuItem.previousElementSibling;\n\n    /* istanbul ignore else */\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n}\n\n/**\n * Toggles on/off the component event listener.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {boolean=} add when `true`, listener is added\n */\nfunction toggleSpyHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.scrollTarget, scrollEvent, self.refresh, passiveHandler);\n}\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nclass ScrollSpy extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   * @param {BSN.Options.ScrollSpy=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element & options\n    const { element, options } = self;\n\n    // additional properties\n    /** @type {HTMLElement?} */\n    self.target = querySelector(options.target, getDocument(element));\n\n    // invalidate\n    if (!self.target) return;\n\n    // set initial state\n    /** @type {HTMLElement | Window} */\n    self.scrollTarget = element.clientHeight < element.scrollHeight\n      ? element : getWindow(element);\n    /** @type {number} */\n    self.scrollTop = 0;\n    /** @type {number} */\n    self.maxScroll = 0;\n    /** @type {number} */\n    self.scrollHeight = 0;\n    /** @type {HTMLElement?} */\n    self.activeItem = null;\n    /** @type {HTMLElement[]} */\n    self.items = [];\n    /** @type {number} */\n    self.itemsLength = 0;\n    /** @type {number[]} */\n    self.offsets = [];\n\n    // bind events\n    self.refresh = self.refresh.bind(self);\n\n    // add event handlers\n    toggleSpyHandlers(self, true);\n\n    self.refresh();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */\n  get name() { return scrollspyComponent; }\n  /**\n   * Returns component default options.\n   */\n  get defaults() { return scrollspyDefaults; }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh() {\n    const self = this;\n    const { target } = self;\n\n    // check if target is visible and invalidate\n    /* istanbul ignore next */\n    if (target.offsetHeight === 0) return;\n\n    updateSpyTargets(self);\n\n    const {\n      scrollTop, maxScroll, itemsLength, items, activeItem,\n    } = self;\n\n    if (scrollTop >= maxScroll) {\n      const newActiveItem = items[itemsLength - 1];\n\n      /* istanbul ignore else */\n      if (activeItem !== newActiveItem) {\n        activate(self, newActiveItem);\n      }\n      return;\n    }\n\n    const { offsets } = self;\n\n    if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n      self.activeItem = null;\n      clear(target);\n      return;\n    }\n\n    items.forEach((item, i) => {\n      if (activeItem !== item && scrollTop >= offsets[i]\n        && (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])) {\n        activate(self, item);\n      }\n    });\n  }\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    toggleSpyHandlers(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(ScrollSpy, {\n  selector: scrollspySelector,\n  init: scrollspyInitCallback,\n  getInstance: getScrollSpyInstance,\n});\n\n/**\n * A global namespace for aria-selected.\n * @type {string}\n */\nconst ariaSelected = 'aria-selected';\n\n/** @type {string} */\nconst tabString = 'tab';\n\n/** @type {string} */\nconst tabComponent = 'Tab';\n\n/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tab>}\n */\nconst getTabInstance = (element) => getInstance(element, tabComponent);\n\n/**\n * A `Tab` initialization callback.\n * @type {BSN.InitCallback<Tab>}\n */\nconst tabInitCallback = (element) => new Tab(element);\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = OriginalEvent(`show.bs.${tabString}`);\nconst shownTabEvent = OriginalEvent(`shown.bs.${tabString}`);\nconst hideTabEvent = OriginalEvent(`hide.bs.${tabString}`);\nconst hiddenTabEvent = OriginalEvent(`hidden.bs.${tabString}`);\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n * @type {Map<HTMLElement, any>}\n */\nconst tabPrivate = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabEnd(self) {\n  const { tabContent, nav } = self;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    tabContent.style.height = '';\n    removeClass(tabContent, collapsingClass);\n  }\n\n  /* istanbul ignore else */\n  if (nav) Timer.clear(nav);\n}\n\n/**\n * Executes before showing the tab content.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabShow(self) {\n  const {\n    element, tabContent, content: nextContent, nav,\n  } = self;\n  const { tab } = nav && tabPrivate.get(nav);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const { currentHeight, nextHeight } = tabPrivate.get(element);\n    if (currentHeight === nextHeight) {\n      triggerTabEnd(self);\n    } else {\n      // enables height animation\n      setTimeout(() => {\n        tabContent.style.height = `${nextHeight}px`;\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab;\n  dispatchEvent(element, shownTabEvent);\n}\n\n/**\n * Executes before hiding the tab.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabHide(self) {\n  const {\n    element, content: nextContent, tabContent, nav,\n  } = self;\n  const { tab, content } = nav && tabPrivate.get(nav);\n  let currentHeight = 0;\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach((c) => {\n      addClass(c, 'overflow-hidden');\n    });\n    currentHeight = content.scrollHeight || /* istanbul ignore next */0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n  if (showTabEvent.defaultPrevented) return;\n\n  addClass(nextContent, activeClass);\n  removeClass(content, activeClass);\n\n  /* istanbul ignore else */\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const nextHeight = nextContent.scrollHeight;\n    tabPrivate.set(element, { currentHeight, nextHeight });\n\n    addClass(tabContent, collapsingClass);\n    tabContent.style.height = `${currentHeight}px`;\n    reflow(tabContent);\n    [content, nextContent].forEach((c) => {\n      removeClass(c, 'overflow-hidden');\n    });\n  }\n\n  if (nextContent && hasClass(nextContent, fadeClass)) {\n    setTimeout(() => {\n      addClass(nextContent, showClass);\n      emulateTransitionEnd(nextContent, () => {\n        triggerTabShow(self);\n      });\n    }, 1);\n  } else {\n    addClass(nextContent, showClass);\n    triggerTabShow(self);\n  }\n\n  dispatchEvent(tab, hiddenTabEvent);\n}\n\n/**\n * Returns the current active tab and its target content.\n * @param {Tab} self the `Tab` instance\n * @returns {Record<string, any>} the query result\n */\nfunction getActiveTab(self) {\n  const { nav } = self;\n\n  const activeTabs = getElementsByClassName(activeClass, nav);\n  /** @type {(HTMLElement)=} */\n  let tab;\n  /* istanbul ignore else */\n  if (activeTabs.length === 1\n    && !dropdownMenuClasses.some((c) => hasClass(activeTabs[0].parentElement, c))) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = tab ? getTargetElement(tab) : null;\n  return { tab, content };\n}\n\n/**\n * Returns a parent dropdown.\n * @param {HTMLElement} element the `Tab` element\n * @returns {HTMLElement?} the parent dropdown\n */\nfunction getParentDropdown(element) {\n  const dropdown = closest(element, `.${dropdownMenuClasses.join(',.')}`);\n  return dropdown ? querySelector(`.${dropdownMenuClasses[0]}-toggle`, dropdown) : null;\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Tab} self the `Tab` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleTabHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, tabClickHandler);\n}\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction tabClickHandler(e) {\n  const self = getTabInstance(this);\n  /* istanbul ignore next: must filter */\n  if (!self) return;\n  e.preventDefault();\n\n  self.show();\n}\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nclass Tab extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target element\n   */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    if (!content) return;\n\n    const nav = closest(element, '.nav');\n    const container = closest(content, '.tab-content');\n\n    /** @type {HTMLElement?} */\n    self.nav = nav;\n    /** @type {HTMLElement} */\n    self.content = content;\n    /** @type {HTMLElement?} */\n    self.tabContent = container;\n\n    // event targets\n    /** @type {HTMLElement?} */\n    self.dropdown = getParentDropdown(element);\n\n    // show first Tab instance of none is shown\n    // suggested on #432\n    const { tab } = getActiveTab(self);\n    if (nav && !tab) {\n      const firstTab = querySelector(tabSelector, nav);\n      const firstTabContent = firstTab && getTargetElement(firstTab);\n\n      /* istanbul ignore else */\n      if (firstTabContent) {\n        addClass(firstTab, activeClass);\n        addClass(firstTabContent, showClass);\n        addClass(firstTabContent, activeClass);\n        setAttribute(element, ariaSelected, 'true');\n      }\n    }\n\n    // add event listener\n    toggleTabHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return tabComponent; }\n  /* eslint-enable */\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const self = this;\n    const {\n      element, content: nextContent, nav, dropdown,\n    } = self;\n\n    /* istanbul ignore else */\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(self);\n\n      /* istanbul ignore else */\n      if (nav) tabPrivate.set(nav, { tab, content });\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      dispatchEvent(tab, hideTabEvent);\n      if (hideTabEvent.defaultPrevented) return;\n\n      addClass(element, activeClass);\n      setAttribute(element, ariaSelected, 'true');\n\n      const activeDropdown = getParentDropdown(tab);\n      if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n        removeClass(activeDropdown, activeClass);\n      }\n\n      /* istanbul ignore else */\n      if (nav) {\n        const toggleTab = () => {\n          removeClass(tab, activeClass);\n          setAttribute(tab, ariaSelected, 'false');\n          if (dropdown && !hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);\n        };\n\n        if (hasClass(content, fadeClass) || hasClass(nextContent, fadeClass)) {\n          Timer.set(nav, toggleTab, 1);\n        } else toggleTab();\n      }\n\n      removeClass(content, showClass);\n      if (hasClass(content, fadeClass)) {\n        emulateTransitionEnd(content, () => triggerTabHide(self));\n      } else {\n        triggerTabHide(self);\n      }\n    }\n  }\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    toggleTabHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Tab, {\n  selector: tabSelector,\n  init: tabInitCallback,\n  getInstance: getTabInstance,\n});\n\n/** @type {string} */\nconst toastString = 'toast';\n\n/** @type {string} */\nconst toastComponent = 'Toast';\n\n/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst toastToggleSelector = `[${dataBsToggle}=\"${toastString}\"]`;\nconst showingClass = 'showing';\n/** @deprecated */\nconst hideClass = 'hide';\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Toast>}\n */\nconst getToastInstance = (element) => getInstance(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n * @type {BSN.InitCallback<Toast>}\n */\nconst toastInitCallback = (element) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = OriginalEvent(`show.bs.${toastString}`);\nconst shownToastEvent = OriginalEvent(`shown.bs.${toastString}`);\nconst hideToastEvent = OriginalEvent(`hide.bs.${toastString}`);\nconst hiddenToastEvent = OriginalEvent(`hidden.bs.${toastString}`);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToastComplete(self) {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  /* istanbul ignore else */\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n}\n\n/**\n * Executes after the toast is hidden to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToastComplete(self) {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n}\n\n/**\n * Executes before hiding the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToast(self) {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n}\n\n/**\n * Executes before showing the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToast(self) {\n  const { element, options } = self;\n  Timer.set(element, () => {\n    removeClass(element, hideClass); // B/C\n    reflow(element);\n    addClass(element, showClass);\n    addClass(element, showingClass);\n\n    if (options.animation) {\n      emulateTransitionEnd(element, () => showToastComplete(self));\n    } else {\n      showToastComplete(self);\n    }\n  }, 17, showingClass);\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Toast} self the `Toast` instance\n * @param {boolean=} add when `true`, it will add the listener\n */\nfunction toggleToastHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const {\n    element, triggers, dismiss, options,\n  } = self;\n\n  /* istanbul ignore else */\n  if (dismiss) {\n    action(dismiss, mouseclickEvent, self.hide);\n  }\n\n  /* istanbul ignore else */\n  if (options.autohide) {\n    [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent]\n      .forEach((e) => action(element, e, interactiveToastHandler));\n  }\n  /* istanbul ignore else */\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, toastClickHandler));\n  }\n}\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Executes after the instance has been disposed.\n * @param {Toast} self the `Toast` instance\n */\nfunction completeDisposeToast(self) {\n  Timer.clear(self.element, toastString);\n  toggleToastHandlers(self);\n}\n\n/**\n * Handles the `click` event listener for toast.\n * @param {MouseEvent} e the `Event` object\n */\nfunction toastClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(target, toastToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getToastInstance(element);\n\n  /* istanbul ignore else */\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.show();\n}\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Toast` instance\n */\nfunction interactiveToastHandler(e) {\n  const element = this;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n\n  /* istanbul ignore next: a solid filter is required */\n  if (!self || (element === relatedTarget || element.contains(relatedTarget))) return;\n\n  if ([mouseenterEvent, focusinEvent].includes(type)) {\n    Timer.clear(element, toastString);\n  } else {\n    Timer.set(element, () => self.hide(), self.options.delay, toastString);\n  }\n}\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nclass Toast extends BaseComponent {\n  /**\n   * @param {HTMLElement | string} target the target `.toast` element\n   * @param {BSN.Options.Toast=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    const { element, options } = self;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) addClass(element, fadeClass);\n    else if (!options.animation && hasClass(element, fadeClass)) removeClass(element, fadeClass);\n\n    // dismiss button\n    /** @type {HTMLElement?} */\n    self.dismiss = querySelector(toastDismissSelector, element);\n\n    // toast can have multiple triggering elements\n    /** @type {HTMLElement[]} */\n    self.triggers = [...querySelectorAll(toastToggleSelector, getDocument(element))]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // bind\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n\n    // add event listener\n    toggleToastHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   */  \n  get name() { return toastComponent; }\n  /**\n   * Returns component default options.\n   */  \n  get defaults() { return toastDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Returns *true* when toast is visible.\n   */\n  get isShown() { return hasClass(this.element, showClass); }\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && !isShown) {\n      dispatchEvent(element, showToastEvent);\n      if (showToastEvent.defaultPrevented) return;\n\n      showToast(self);\n    }\n  }\n\n  /** Hides the toast. */\n  hide() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (element && isShown) {\n      dispatchEvent(element, hideToastEvent);\n      if (hideToastEvent.defaultPrevented) return;\n      hideToast(self);\n    }\n  }\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const self = this;\n    const { element, isShown } = self;\n\n    /* istanbul ignore else */\n    if (isShown) {\n      removeClass(element, showClass);\n    }\n\n    completeDisposeToast(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Toast, {\n  selector: toastSelector,\n  init: toastInitCallback,\n  getInstance: getToastInstance,\n});\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {HTMLElement} target\n * @param {string} selector\n * @returns {boolean}\n */\nfunction matches(target, selector) {\n  return target.matches(selector);\n}\n\n/** @type {Record<string, any>} */\nconst componentsList = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n};\n\n/**\n * Initialize all matched `Element`s for one component.\n * @param {BSN.InitCallback<any>} callback\n * @param {NodeList | Node[]} collection\n */\nfunction initComponentDataAPI(callback, collection) {\n  [...collection].forEach((x) => callback(x));\n}\n\n/**\n * Remove one component from a target container element or all in the page.\n * @param {string} component the component name\n * @param {ParentNode} context parent `Node`\n */\nfunction removeComponentDataAPI(component, context) {\n  const compData = Data.getAllFor(component);\n\n  if (compData) {\n    [...compData].forEach((x) => {\n      const [element, instance] = x;\n      if (context.contains(element)) instance.dispose();\n    });\n  }\n}\n\n/**\n * Initialize all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction initCallback(context) {\n  const lookUp = context && context.nodeName ? context : document;\n  const elemCollection = [...getElementsByTagName('*', lookUp)];\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    const { init, selector } = componentsList[comp];\n    initComponentDataAPI(init, elemCollection.filter((item) => matches(item, selector)));\n  });\n}\n\n/**\n * Remove all BSN components for a target container.\n * @param {ParentNode=} context parent `Node`\n */\nfunction removeDataAPI(context) {\n  const lookUp = context && context.nodeName ? context : document;\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    removeComponentDataAPI(comp, lookUp);\n  });\n}\n\n// bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, 'DOMContentLoaded', () => initCallback(), { once: true });\n}\n\nconst BSN = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n\n  initCallback,\n  removeDataAPI,\n  Version,\n  EventListener: Listener,\n};\n\nexport { BSN as default };\n","import BSN from 'bootstrap.native';\n\nconst refs = {\n  modal: document.querySelector('#subscription-modal'),\n  subscribeBtn: document.querySelector('button[data-subscribe]'),\n};\nconst PROMPT_DELAY = 2000;\nconst MAX_PROMPT_ATTEMPTS = 3;\nlet promptCounter = 0;\nlet hasSubscribed = false;\nconst modal = new BSN.Modal('#subscription-modal');\n\nopenModal();\n\nrefs.modal.addEventListener('hide.bs.modal', openModal);\nrefs.subscribeBtn.addEventListener('click', onSubscribeBtnClick);\n\nfunction openModal() {\n  if (promptCounter === MAX_PROMPT_ATTEMPTS || hasSubscribed) {\n    console.log(' -   ');\n    return;\n  }\n\n  setTimeout(() => {\n    console.log(' ');\n    modal.show();\n    promptCounter += 1;\n  }, PROMPT_DELAY);\n}\n\nfunction onSubscribeBtnClick() {\n  hasSubscribed = true;\n  modal.hide();\n}\n"],"names":["$7e4c9fa4960e8acf$var$EventRegistry","$7e4c9fa4960e8acf$var$globalListener","e","that","this","type","forEach","elementsMap","element","listenersMap","listenerMap","listener","options","apply","once","$7e4c9fa4960e8acf$var$removeListener","$7e4c9fa4960e8acf$var$addListener","eventType","Map","oneEventMap","has","set","oneElementMap","get","size","addEventListener","savedOptions","eventOptions","undefined","delete","removeEventListener","$7e4c9fa4960e8acf$var$Listener","on","off","registry","$7e4c9fa4960e8acf$var$mouseclickEvent","$7e4c9fa4960e8acf$var$transitionEndEvent","$7e4c9fa4960e8acf$var$transitionProperty","$7e4c9fa4960e8acf$var$getElementStyle","property","computedStyle","getComputedStyle","includes","getPropertyValue","$7e4c9fa4960e8acf$var$getElementTransitionDuration","propertyValue","durationValue","durationScale","duration","parseFloat","Number","isNaN","$7e4c9fa4960e8acf$var$dispatchEvent","event","dispatchEvent","$7e4c9fa4960e8acf$var$emulateTransitionEnd","handler","called","endEvent","Event","delay","delayValue","delayScale","$7e4c9fa4960e8acf$var$getElementTransitionDelay","transitionEndWrapper","target","setTimeout","$7e4c9fa4960e8acf$var$isNode","some","x","nodeType","$7e4c9fa4960e8acf$var$isWindow","object","constructor","name","$7e4c9fa4960e8acf$var$isDocument","$7e4c9fa4960e8acf$var$getDocument","node","ownerDocument","document","window","$7e4c9fa4960e8acf$var$querySelector","selector","parent","querySelector","$7e4c9fa4960e8acf$var$closest","closest","getRootNode","host","$7e4c9fa4960e8acf$var$ObjectAssign","obj","source","Object","assign","$7e4c9fa4960e8acf$var$hasClass","classNAME","classList","contains","$7e4c9fa4960e8acf$var$removeClass","remove","$7e4c9fa4960e8acf$var$isHTMLElement","$7e4c9fa4960e8acf$var$componentData","$7e4c9fa4960e8acf$var$Data","component","instance","getAllFor","allForC","instanceMap","$7e4c9fa4960e8acf$var$getInstance","$7e4c9fa4960e8acf$var$OriginalEvent","EventType","config","OriginalCustomEvent","CustomEvent","cancelable","bubbles","$7e4c9fa4960e8acf$var$fadeClass","$7e4c9fa4960e8acf$var$showClass","$7e4c9fa4960e8acf$var$dataBsDismiss","$7e4c9fa4960e8acf$var$alertString","$7e4c9fa4960e8acf$var$alertComponent","$7e4c9fa4960e8acf$var$getAttribute","attribute","getAttribute","$7e4c9fa4960e8acf$var$normalizeValue","value","$7e4c9fa4960e8acf$var$ObjectKeys","keys","$7e4c9fa4960e8acf$var$toLowerCase","toLowerCase","$7e4c9fa4960e8acf$var$Version","$7e4c9fa4960e8acf$var$BaseComponent","self","Error","prevInstance","dispose","defaults","length","defaultOps","inputOps","ns","data","dataset","normalOps","dataOps","title","k","key","replace","match","$7e4c9fa4960e8acf$var$normalizeOptions","version","prop","$7e4c9fa4960e8acf$var$alertSelector","$7e4c9fa4960e8acf$var$alertDismissSelector","$7e4c9fa4960e8acf$var$getAlertInstance","$7e4c9fa4960e8acf$var$closeAlertEvent","$7e4c9fa4960e8acf$var$closedAlertEvent","$7e4c9fa4960e8acf$var$alertTransitionEnd","$7e4c9fa4960e8acf$var$toggleAlertHandler","add","action","dismiss","close","$7e4c9fa4960e8acf$var$Alert","super","defaultPrevented","init","getInstance","$7e4c9fa4960e8acf$var$ariaPressed","$7e4c9fa4960e8acf$var$setAttribute","setAttribute","$7e4c9fa4960e8acf$var$addClass","$7e4c9fa4960e8acf$var$activeClass","$7e4c9fa4960e8acf$var$dataBsToggle","$7e4c9fa4960e8acf$var$buttonComponent","$7e4c9fa4960e8acf$var$buttonSelector","$7e4c9fa4960e8acf$var$getButtonInstance","$7e4c9fa4960e8acf$var$toggleButtonHandler","toggle","$7e4c9fa4960e8acf$var$Button","isActive","preventDefault","$7e4c9fa4960e8acf$var$mouseenterEvent","$7e4c9fa4960e8acf$var$mouseleaveEvent","$7e4c9fa4960e8acf$var$keydownEvent","$7e4c9fa4960e8acf$var$keyArrowLeft","$7e4c9fa4960e8acf$var$keyArrowRight","$7e4c9fa4960e8acf$var$getBoundingClientRect","includeScale","width","height","top","right","bottom","left","getBoundingClientRect","scaleX","scaleY","offsetWidth","offsetHeight","Math","round","y","$7e4c9fa4960e8acf$var$getDocumentElement","documentElement","$7e4c9fa4960e8acf$var$isElementInScrollRange","clientHeight","$7e4c9fa4960e8acf$var$isRTL","dir","$7e4c9fa4960e8acf$var$querySelectorAll","querySelectorAll","$7e4c9fa4960e8acf$var$getElementsByClassName","getElementsByClassName","$7e4c9fa4960e8acf$var$TimeCache","$7e4c9fa4960e8acf$var$Timer","callback","keyTimers","clearTimeout","$7e4c9fa4960e8acf$var$reflow","$7e4c9fa4960e8acf$var$passiveHandler","passive","$7e4c9fa4960e8acf$var$dataBsTarget","$7e4c9fa4960e8acf$var$carouselString","$7e4c9fa4960e8acf$var$carouselComponent","$7e4c9fa4960e8acf$var$dataBsParent","$7e4c9fa4960e8acf$var$getTargetElement","targetAttr","doc","map","att","attValue","filter","$7e4c9fa4960e8acf$var$carouselSelector","$7e4c9fa4960e8acf$var$carouselItem","$7e4c9fa4960e8acf$var$dataBsSlideTo","$7e4c9fa4960e8acf$var$dataBsSlide","$7e4c9fa4960e8acf$var$pausedClass","$7e4c9fa4960e8acf$var$carouselDefaults","pause","keyboard","touch","interval","$7e4c9fa4960e8acf$var$getCarouselInstance","$7e4c9fa4960e8acf$var$startX","$7e4c9fa4960e8acf$var$currentX","$7e4c9fa4960e8acf$var$endX","$7e4c9fa4960e8acf$var$carouselSlideEvent","$7e4c9fa4960e8acf$var$carouselSlidEvent","$7e4c9fa4960e8acf$var$carouselPauseHandler","isPaused","$7e4c9fa4960e8acf$var$carouselResumeHandler","cycle","$7e4c9fa4960e8acf$var$carouselIndicatorHandler","indicator","isAnimating","newIndex","to","$7e4c9fa4960e8acf$var$carouselControlsHandler","control","orientation","next","prev","$7e4c9fa4960e8acf$var$carouselKeyHandler","code","test","tagName","RTL","arrowKeyNext","$7e4c9fa4960e8acf$var$carouselPointerDownHandler","controls","indicators","el","isTouch","pageX","$7e4c9fa4960e8acf$var$toggleCarouselTouchHandlers","$7e4c9fa4960e8acf$var$carouselPointerMoveHandler","$7e4c9fa4960e8acf$var$carouselPointerUpHandler","c","find","i","index","getSelection","toString","abs","$7e4c9fa4960e8acf$var$activateCarouselIndicator","pageIndex","$7e4c9fa4960e8acf$var$toggleCarouselHandlers","slides","arrow","$7e4c9fa4960e8acf$var$getActiveIndex","activeItem","indexOf","$7e4c9fa4960e8acf$var$Carousel","direction","id","idx","directionClass","eventProperties","relatedTarget","from","hidden","$7e4c9fa4960e8acf$var$carouselTransitionEndHandler","itemClasses","slide","$7e4c9fa4960e8acf$var$ariaExpanded","$7e4c9fa4960e8acf$var$setElementStyle","styles","entries","style","setProperty","propObject","$7e4c9fa4960e8acf$var$collapsingClass","$7e4c9fa4960e8acf$var$collapseString","$7e4c9fa4960e8acf$var$collapseComponent","$7e4c9fa4960e8acf$var$collapseSelector","$7e4c9fa4960e8acf$var$collapseToggleSelector","$7e4c9fa4960e8acf$var$collapseDefaults","$7e4c9fa4960e8acf$var$getCollapseInstance","$7e4c9fa4960e8acf$var$showCollapseEvent","$7e4c9fa4960e8acf$var$shownCollapseEvent","$7e4c9fa4960e8acf$var$hideCollapseEvent","$7e4c9fa4960e8acf$var$hiddenCollapseEvent","$7e4c9fa4960e8acf$var$collapseContent","triggers","scrollHeight","btn","$7e4c9fa4960e8acf$var$toggleCollapseHandler","$7e4c9fa4960e8acf$var$collapseClickHandler","trigger","$7e4c9fa4960e8acf$var$Collapse","hide","show","activeCollapse","activeCollapseInstance","$7e4c9fa4960e8acf$var$expandCollapse","$7e4c9fa4960e8acf$var$focusEvent","$7e4c9fa4960e8acf$var$scrollEvent","$7e4c9fa4960e8acf$var$resizeEvent","$7e4c9fa4960e8acf$var$keyArrowUp","$7e4c9fa4960e8acf$var$keyArrowDown","$7e4c9fa4960e8acf$var$keyEscape","$7e4c9fa4960e8acf$var$hasAttribute","hasAttribute","$7e4c9fa4960e8acf$var$focus","focus","$7e4c9fa4960e8acf$var$getWindow","defaultView","$7e4c9fa4960e8acf$var$dropdownMenuClasses","$7e4c9fa4960e8acf$var$dropdownComponent","$7e4c9fa4960e8acf$var$dropdownMenuClass","$7e4c9fa4960e8acf$var$isEmptyAnchor","parentAnchor","href","slice","$7e4c9fa4960e8acf$var$dropdownString","$7e4c9fa4960e8acf$var$dropupString","$7e4c9fa4960e8acf$var$dropstartString","$7e4c9fa4960e8acf$var$dropendString","$7e4c9fa4960e8acf$var$dropdownSelector","$7e4c9fa4960e8acf$var$getDropdownInstance","$7e4c9fa4960e8acf$var$dropdownMenuEndClass","$7e4c9fa4960e8acf$var$verticalClass","$7e4c9fa4960e8acf$var$horizontalClass","$7e4c9fa4960e8acf$var$menuFocusTags","$7e4c9fa4960e8acf$var$dropdownDefaults","offset","display","$7e4c9fa4960e8acf$var$showDropdownEvent","$7e4c9fa4960e8acf$var$shownDropdownEvent","$7e4c9fa4960e8acf$var$hideDropdownEvent","$7e4c9fa4960e8acf$var$hiddenDropdownEvent","$7e4c9fa4960e8acf$var$styleDropdown","menu","parentElement","menuEnd","p","positionClass","dropdownMargin","dropdown","dropup","dropstart","dropend","dropdownPosition","menuStart","menuWidth","menuHeight","clientWidth","targetLeft","targetTop","targetWidth","targetHeight","leftFullExceed","rightFullExceed","bottomExceed","bottomFullExceed","topExceed","leftExceed","rightExceed","posAjust","margin","join","$7e4c9fa4960e8acf$var$toggleDropdownDismiss","open","$7e4c9fa4960e8acf$var$dropdownDismissHandler","$7e4c9fa4960e8acf$var$dropdownPreventScroll","$7e4c9fa4960e8acf$var$dropdownKeyHandler","ev","$7e4c9fa4960e8acf$var$dropdownLayoutHandler","$7e4c9fa4960e8acf$var$toggleDropdownHandler","$7e4c9fa4960e8acf$var$dropdownClickHandler","$7e4c9fa4960e8acf$var$getCurrentOpenDropdown","currentParent","children","hasData","isForm","activeElement","menuItems","firstElementChild","$7e4c9fa4960e8acf$var$getMenuItems","$7e4c9fa4960e8acf$var$Dropdown","currentElement","currentInstance","$7e4c9fa4960e8acf$var$ariaHidden","$7e4c9fa4960e8acf$var$ariaModal","$7e4c9fa4960e8acf$var$removeAttribute","removeAttribute","$7e4c9fa4960e8acf$var$getDocumentBody","body","$7e4c9fa4960e8acf$var$modalString","$7e4c9fa4960e8acf$var$modalComponent","$7e4c9fa4960e8acf$var$isShadowRoot","$7e4c9fa4960e8acf$var$isTableElement","$7e4c9fa4960e8acf$var$getElementContainer","getOffset","majorBlockTags","offsetParent","win","containers","parentNode","nodeName","assignedSlot","shadowRoot","push","every","r","$7e4c9fa4960e8acf$var$stickyTopClass","$7e4c9fa4960e8acf$var$positionStickyClass","$7e4c9fa4960e8acf$var$getFixedItems","$7e4c9fa4960e8acf$var$measureScrollbar","innerWidth","$7e4c9fa4960e8acf$var$setScrollbar","overflow","bd","bodyPad","parseInt","sbWidth","fixedItems","paddingRight","fixed","itemPadValue","itemMValue","marginRight","$7e4c9fa4960e8acf$var$createElement","param","createElement","attr","newElement","$7e4c9fa4960e8acf$var$offcanvasString","$7e4c9fa4960e8acf$var$backdropString","$7e4c9fa4960e8acf$var$modalBackdropClass","$7e4c9fa4960e8acf$var$offcanvasBackdropClass","$7e4c9fa4960e8acf$var$modalActiveSelector","$7e4c9fa4960e8acf$var$offcanvasActiveSelector","$7e4c9fa4960e8acf$var$overlay","$7e4c9fa4960e8acf$var$getCurrentOpen","$7e4c9fa4960e8acf$var$toggleOverlayType","isModal","targetClass","$7e4c9fa4960e8acf$var$appendOverlay","container","hasFade","append","$7e4c9fa4960e8acf$var$showOverlay","$7e4c9fa4960e8acf$var$hideOverlay","$7e4c9fa4960e8acf$var$removeOverlay","$7e4c9fa4960e8acf$var$resetScrollbar","$7e4c9fa4960e8acf$var$isVisible","$7e4c9fa4960e8acf$var$modalSelector","$7e4c9fa4960e8acf$var$modalToggleSelector","$7e4c9fa4960e8acf$var$modalDismissSelector","$7e4c9fa4960e8acf$var$modalStaticClass","$7e4c9fa4960e8acf$var$modalDefaults","backdrop","$7e4c9fa4960e8acf$var$getModalInstance","$7e4c9fa4960e8acf$var$showModalEvent","$7e4c9fa4960e8acf$var$shownModalEvent","$7e4c9fa4960e8acf$var$hideModalEvent","$7e4c9fa4960e8acf$var$hiddenModalEvent","$7e4c9fa4960e8acf$var$setModalScrollbar","scrollbarWidth","modalHeight","modalScrollHeight","modalOverflow","padStyle","$7e4c9fa4960e8acf$var$toggleModalDismiss","$7e4c9fa4960e8acf$var$modalDismissHandler","update","$7e4c9fa4960e8acf$var$modalKeyHandler","$7e4c9fa4960e8acf$var$toggleModalHandler","$7e4c9fa4960e8acf$var$modalClickHandler","$7e4c9fa4960e8acf$var$afterModalHide","focusElement","$7e4c9fa4960e8acf$var$afterModalShow","$7e4c9fa4960e8acf$var$beforeModalShow","$7e4c9fa4960e8acf$var$beforeModalHide","isStatic","modalDialog","selectedText","targetInsideDialog","$7e4c9fa4960e8acf$var$staticTransitionEnd","$7e4c9fa4960e8acf$var$Modal","bind","overlayDelay","currentOpen","$7e4c9fa4960e8acf$var$offcanvasComponent","$7e4c9fa4960e8acf$var$offcanvasSelector","$7e4c9fa4960e8acf$var$offcanvasToggleSelector","$7e4c9fa4960e8acf$var$offcanvasDismissSelector","$7e4c9fa4960e8acf$var$offcanvasTogglingClass","$7e4c9fa4960e8acf$var$offcanvasDefaults","scroll","$7e4c9fa4960e8acf$var$getOffcanvasInstance","$7e4c9fa4960e8acf$var$showOffcanvasEvent","$7e4c9fa4960e8acf$var$shownOffcanvasEvent","$7e4c9fa4960e8acf$var$hideOffcanvasEvent","$7e4c9fa4960e8acf$var$hiddenOffcanvasEvent","$7e4c9fa4960e8acf$var$toggleOffcanvasEvents","$7e4c9fa4960e8acf$var$offcanvasTriggerHandler","$7e4c9fa4960e8acf$var$toggleOffCanvasDismiss","$7e4c9fa4960e8acf$var$offcanvasKeyDismissHandler","$7e4c9fa4960e8acf$var$offcanvasDismissHandler","$7e4c9fa4960e8acf$var$beforeOffcanvasShow","$7e4c9fa4960e8acf$var$setOffCanvasScrollbar","visibility","$7e4c9fa4960e8acf$var$showOffcanvasComplete","$7e4c9fa4960e8acf$var$beforeOffcanvasHide","blur","$7e4c9fa4960e8acf$var$hideOffcanvasComplete","offCanvasDismiss","selection","visibleTrigger","$7e4c9fa4960e8acf$var$Offcanvas","$7e4c9fa4960e8acf$var$popoverString","$7e4c9fa4960e8acf$var$popoverComponent","$7e4c9fa4960e8acf$var$tooltipString","$7e4c9fa4960e8acf$var$getTipTemplate","tipType","isTooltip","$7e4c9fa4960e8acf$var$isMedia","s","$7e4c9fa4960e8acf$var$getRectRelativeToOffsetParent","isParentAnElement","rect","$7e4c9fa4960e8acf$var$isScaledElement","offsets","offsetRect","clientLeft","clientTop","$7e4c9fa4960e8acf$var$tipClassPositions","$7e4c9fa4960e8acf$var$styleTip","tooltip","tipPositions","isPopover","tipWidth","tipHeight","htmlcw","htmlch","placement","parentLeft","parentRight","parentTop","parentCWidth","parentOWidth","parentPosition","fixedParent","staticParent","isSticky","leftBoundry","rightBoundry","elemWidth","elemHeight","elemRectLeft","elemRectRight","elemRectTop","isWin","scrollX","scrollLeft","scrollY","scrollTop","$7e4c9fa4960e8acf$var$getNodeScroll","topPosition","leftPosition","rightPosition","arrowTop","arrowLeft","arrowRight","arrowWidth","arrowHeight","arrowAdjust","horizontal","vertical","className","eX","eY","pageY","clientX","clientY","$7e4c9fa4960e8acf$var$tooltipDefaults","template","customClass","sanitizeFn","animation","$7e4c9fa4960e8acf$var$ariaDescribedBy","$7e4c9fa4960e8acf$var$focusinEvent","$7e4c9fa4960e8acf$var$focusoutEvent","$7e4c9fa4960e8acf$var$touchstartEvent","$7e4c9fa4960e8acf$var$elementUID","$7e4c9fa4960e8acf$var$elementMapUID","$7e4c9fa4960e8acf$var$elementIDMap","$7e4c9fa4960e8acf$var$getUID","result","elID","elMap","elkey","$7e4c9fa4960e8acf$var$isFunction","fn","userAgentData","$7e4c9fa4960e8acf$var$uaDATA","navigator","$7e4c9fa4960e8acf$var$userAgentData","userAgent","$7e4c9fa4960e8acf$var$userAgentString","$7e4c9fa4960e8acf$var$userAgent","$7e4c9fa4960e8acf$var$appleBrands","$7e4c9fa4960e8acf$var$isApple","brands","brand","$7e4c9fa4960e8acf$var$dataOriginalTitle","$7e4c9fa4960e8acf$var$tooltipComponent","$7e4c9fa4960e8acf$var$isString","str","$7e4c9fa4960e8acf$var$setHtml","content","arr","dirty","trim","tempDocument","DOMParser","parseFromString","childNodes","Array","isArray","$7e4c9fa4960e8acf$var$isVisibleTip","tip","$7e4c9fa4960e8acf$var$tooltipSelector","$7e4c9fa4960e8acf$var$titleAttr","$7e4c9fa4960e8acf$var$getTooltipInstance","$7e4c9fa4960e8acf$var$toggleTooltipAction","handleTouch","$7e4c9fa4960e8acf$var$tooltipShownAction","shownTooltipEvent","$7e4c9fa4960e8acf$var$tooltipHiddenAction","hiddenTooltipEvent","$7e4c9fa4960e8acf$var$removeTooltip","$7e4c9fa4960e8acf$var$toggleTooltipHandlers","dismissible","enabled","triggerOptions","split","elemIsMedia","tr","$7e4c9fa4960e8acf$var$toggleTooltipOpenHandlers","parentModal","parentOffcanvas","scrollTarget","$7e4c9fa4960e8acf$var$toggleTooltipTitle","titleAtt","$7e4c9fa4960e8acf$var$Tooltip","tipString","tipComponent","elem","idealContainer","btnClose","titleParts","contentParts","placementClass","tooltipTemplate","htmlMarkup","firstChild","cloneNode","bodyClass","tooltipHeader","tooltipBody","tempTitle","tempContent","tempBtn","tempBtn1","$7e4c9fa4960e8acf$var$createTip","outTimer","showTooltipEvent","hideTooltipEvent","enable","disable","toggleEnabled","$7e4c9fa4960e8acf$var$disposeTooltipComplete","$7e4c9fa4960e8acf$var$popoverSelector","$7e4c9fa4960e8acf$var$popoverDefaults","$7e4c9fa4960e8acf$var$Popover","$7e4c9fa4960e8acf$var$getElementsByTagName","getElementsByTagName","$7e4c9fa4960e8acf$var$scrollspyComponent","$7e4c9fa4960e8acf$var$scrollspyDefaults","$7e4c9fa4960e8acf$var$activateScrollSpy","$7e4c9fa4960e8acf$var$updateSpyTargets","itemsLength","links","scrollHEIGHT","$7e4c9fa4960e8acf$var$getScrollHeight","targetItem","items","maxScroll","innerHeight","$7e4c9fa4960e8acf$var$getOffsetHeight","link","charAt","offsetTop","$7e4c9fa4960e8acf$var$clear","item","$7e4c9fa4960e8acf$var$activate","parents","parentItem","menuItem","parentLink","previousElementSibling","$7e4c9fa4960e8acf$var$toggleSpyHandlers","refresh","$7e4c9fa4960e8acf$var$ScrollSpy","newActiveItem","$7e4c9fa4960e8acf$var$ariaSelected","$7e4c9fa4960e8acf$var$tabString","$7e4c9fa4960e8acf$var$tabSelector","$7e4c9fa4960e8acf$var$getTabInstance","$7e4c9fa4960e8acf$var$showTabEvent","$7e4c9fa4960e8acf$var$shownTabEvent","$7e4c9fa4960e8acf$var$hideTabEvent","$7e4c9fa4960e8acf$var$hiddenTabEvent","$7e4c9fa4960e8acf$var$tabPrivate","$7e4c9fa4960e8acf$var$triggerTabEnd","tabContent","nav","$7e4c9fa4960e8acf$var$triggerTabShow","nextContent","tab","currentHeight","nextHeight","$7e4c9fa4960e8acf$var$triggerTabHide","$7e4c9fa4960e8acf$var$getActiveTab","activeTabs","$7e4c9fa4960e8acf$var$getParentDropdown","$7e4c9fa4960e8acf$var$toggleTabHandler","$7e4c9fa4960e8acf$var$tabClickHandler","$7e4c9fa4960e8acf$var$Tab","firstTab","firstTabContent","activeDropdown","toggleTab","$7e4c9fa4960e8acf$var$toastString","$7e4c9fa4960e8acf$var$toastComponent","$7e4c9fa4960e8acf$var$toastSelector","$7e4c9fa4960e8acf$var$toastDismissSelector","$7e4c9fa4960e8acf$var$toastToggleSelector","$7e4c9fa4960e8acf$var$showingClass","$7e4c9fa4960e8acf$var$hideClass","$7e4c9fa4960e8acf$var$toastDefaults","autohide","$7e4c9fa4960e8acf$var$getToastInstance","$7e4c9fa4960e8acf$var$showToastEvent","$7e4c9fa4960e8acf$var$shownToastEvent","$7e4c9fa4960e8acf$var$hideToastEvent","$7e4c9fa4960e8acf$var$hiddenToastEvent","$7e4c9fa4960e8acf$var$showToastComplete","$7e4c9fa4960e8acf$var$hideToastComplete","$7e4c9fa4960e8acf$var$toggleToastHandlers","$7e4c9fa4960e8acf$var$interactiveToastHandler","$7e4c9fa4960e8acf$var$toastClickHandler","$7e4c9fa4960e8acf$var$Toast","isShown","$7e4c9fa4960e8acf$var$showToast","$7e4c9fa4960e8acf$var$hideToast","$7e4c9fa4960e8acf$var$completeDisposeToast","$7e4c9fa4960e8acf$var$componentsList","$7e4c9fa4960e8acf$var$initCallback","context","elemCollection","comp","collection","matches","$7e4c9fa4960e8acf$var$matches","$7e4c9fa4960e8acf$export$2e2bcd8739ae039","lookUp","compData","$7e4c9fa4960e8acf$var$removeComponentDataAPI","EventListener","$77885c71bce77962$var$refs","modal","subscribeBtn","$77885c71bce77962$var$promptCounter","$77885c71bce77962$var$hasSubscribed","$77885c71bce77962$var$modal","Modal","$77885c71bce77962$var$openModal","console","log"],"version":3,"file":"04-subscription.52481e5f.js.map"}